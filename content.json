{"meta":{"title":"happyJared - 博客","subtitle":"不只做技术的个人博客 - power by Hexo","description":"Java developer, like Python and javascript，为人乐观、积极、向上、勤奋、和善、好相处，讲卫生，爱学习，爱码字，爱技术，爱生活","author":"Jared Qiu","url":"https://blog.mariojd.cn"},"pages":[],"posts":[{"title":"Python + Selenium 自动发布文章（四）：加入 bat 脚本","slug":"Python + Selenium 自动发布文章（四）：加入 bat 脚本","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2018/05/19/Python + Selenium 自动发布文章（四）：加入 bat 脚本/","link":"","permalink":"https://blog.mariojd.cn/2018/05/19/Python + Selenium 自动发布文章（四）：加入 bat 脚本/","excerpt":"","text":"写在前面&emsp;&emsp;这是本系列的第四篇文章，同时也是最后一篇。有关于Bat脚本和自动发布博客的内容，不太了解的可以先看看之前写的文章。这篇文章是介绍如何整合Bat脚本来一键自动发博客，包括我的Hexo博客、简书、开源中国和CSDN。好了，在那之前我们先稍微调整一下代码。 代码改造&emsp;&emsp;这里只需要调整一下main.py即可，引入sys这个moudle，到时我们通过Bat命令占位符的形式进行传参，参数是Markdown文件名称（含文件后缀.md），参考代码如下： import reimport sysimport csdnimport jianshuimport oschinaclass Main(object): # init def __init__(self, file): self.title = '' self.content = '' self.category = '' self.tags = '' # OsChina的系统分类, 设个默认值 self.osChina_sys_category = '编程语言' # CSDN的文章分类, 设个默认值 self.csdn_article_category = '原创' # CSDN的博客分类, 设个默认值 self.csdn_blog_category = '后端' self.read_file(file) # 读取MD中的title, content, self_category, self_tags, osChina_sys_category, csdn_article_category, csdn_blog_category def read_file(self, markdown_file): with open(markdown_file, 'r', encoding='UTF-8') as f: self.content = f.read().split('--&gt;\\n')[1] # 重置文件指针偏移量 f.seek(0) for line in f.readlines(): if self.judge('title: ', line): self.title = line.split('title: ')[1].strip('\\n') elif self.judge('self_category: ', line): self.category = line.split('self_category: ')[1].strip('\\n') elif self.judge('self_tags: ', line): self.tags = line.split('self_tags: ')[1].strip('\\n') elif self.judge('osChina_sys_category: ', line): self.osChina_sys_category = line.split('osChina_sys_category: ')[1].strip('\\n') elif self.judge('csdn_article_category: ', line): self.csdn_article_category = line.split('csdn_article_category: ')[1].strip('\\n') elif self.judge('csdn_blog_category: ', line): self.csdn_blog_category = line.split('csdn_blog_category: ')[1].strip('\\n') # 正则匹配判断, 获取的信息需保证其标志的唯一性 @staticmethod def judge(rule, line): if re.search(rule, line) is None: return False if 'self.' in line: return False return Trueif __name__ == '__main__': # sys.argv[0] = 当前文件名，这里是main.py md_file = sys.argv[1] # md_file = 'auto.md' print(\"Markdown File is \", md_file) timeout = 10 main = Main(md_file) # 开源中国 osChina = oschina.OsChina() osChina.post(main, timeout) # 简书 jian_shu = jianshu.JianShu() jian_shu.post(main, timeout) # CSDN csdn = csdn.CSDN() csdn.post(main, timeout) Bat 脚本&emsp;&emsp;和以往一样，Bat脚本还是放在hexo的安装目录下，命名deploy.bat。Python + Selenium系列的所有代码已经上传到了我的GitHub仓库，同时为了代码的同步和方便，这里也直接在source\\_posts目录下克隆了该仓库。Okay，关于这个一键部署的脚本参考如下： :: 拉取最新的部署代码cd source/_posts/auto-postgit pull origin master:: 拉取最新的Markdown文章cd ../git pull origin master:: 输入文件名（最好用双引号括起来）才执行一键部署set /p fileName=if defined fileName (start python auto-post/main.py %fileName%):: 这里是部署hexocd ../../hexo g -d 运行效果 可优化点&emsp;&emsp;单从上面的效果图来看，代码就有很大的优化空间了。下面列出去的几点是目前发现已知的可优化点，计划等有时间再来慢慢改进： 部分页面加载等待时间过长：在大多数情况下，其实需要处理元素已经完全加载显示出来了，但实际页面还在等待css、js等资源的完全加载；（可以设置最长加载等待时间） 录入内容可能会很慢：当正文内容很长的时候，用selenium的send_keys方法其实是比较慢的，毕竟这种方式还是一个个字符的输入；（可以利用剪贴板的复制粘贴功能） 可选第三方授权登录方式有限：如代码所示，目前仅有QQ授权的方式；（可以扩展新浪微博、GitHub、微信等渠道进行授权登录） 发布文章的操作是串行的：目前deploy.bat脚本只是整合了这几个平台的发布文章操作，执行顺序是按代码顺序来的；（可以使用多线程技术同步完成多平台的发布操作） 系列小结&emsp;&emsp;小结作个简单说明，本系列所演示的代码目前仅支持发布（单篇）文章，不支持文章的更新和多篇文章同时发布，只能说代码是死的，人才是活的，有时间有兴趣的可以自己捣腾一下。最后，结合这几个平台，附上Markdown中注释部分参数的说明和可选参数值，本系列的所有代码在GitHub仓库中。 参数名 说明/可选参数值 self_category 自定义的分类名称。在OSChina和CSDN叫个人分类，简书里叫文集 self_tags 文章的标签。OSChina和CSDN里用到，多个标签以，（中文逗号+空格）分隔 osChina_sys_category OSChina的系统分类。可选参数值有：移动开发、前端开发、人工智能、服务端开发/管理、游戏开发、编程语言、数据库、企业开发、图像/多媒体、系统运维、软件工程、大数据、云计算、开源硬件、区块链、其他类型 csdn_article_category CSDN的文章类型。可选参数值有：原创、转载、翻译 csdn_blog_category CSDN的博客分类。可选参数值有：人工智能、移动开发、物联网、架构、云计算/大数据、游戏开发、运维、数据库、前端、后端、编程语言、研发管理、安全、程序人生、区块链、音视频开发、资讯、计算机理论与基础","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.mariojd.cn/categories/Python/"},{"name":"Selenium","slug":"Python/Selenium","permalink":"https://blog.mariojd.cn/categories/Python/Selenium/"},{"name":"Windows Batch","slug":"Python/Selenium/Windows-Batch","permalink":"https://blog.mariojd.cn/categories/Python/Selenium/Windows-Batch/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.mariojd.cn/tags/python/"},{"name":"selenium","slug":"selenium","permalink":"https://blog.mariojd.cn/tags/selenium/"},{"name":"bat","slug":"bat","permalink":"https://blog.mariojd.cn/tags/bat/"}]},{"title":"Python + Selenium 自动发布文章（三）：CSDN","slug":"Python + Selenium 自动发布文章（三）：CSDN","date":"un55fin55","updated":"un66fin66","comments":true,"path":"2018/05/18/Python + Selenium 自动发布文章（三）：CSDN/","link":"","permalink":"https://blog.mariojd.cn/2018/05/18/Python + Selenium 自动发布文章（三）：CSDN/","excerpt":"","text":"写在开始&emsp;&emsp;这是本系列的第三篇文章，主要介绍如何用Python+Selenium 自动发布CSDN博客，一些必要的条件在之前的文章里面已经提到过，这里也不再重复。 使用说明&emsp;&emsp;同样的，还是需要先分析下CSDN写博客的界面（记得设置默认编辑器为Markdown）。 &emsp;&emsp;从上面两张图可以看到，在CSDN平台写一篇博客，依次需要填入标题和内容信息。如果是发布博客操作，还需要选择文章类型、博客分类、个人分类（可选）以及填写文章标签（可选）等信息。&emsp;&emsp;我们结合auto.md的内容进行分析，标题定义在title处；正文内容通过匹配--&gt;\\n获取；剩下文章类型、博客分类、文章标签和个人分类，按规则已经提前定义在注释中，分别对应csdn_article_category、csdn_blog_category、self_tags和self_category。 代码说明&emsp;&emsp;main.py：程序入口类，主要负责正则匹配解析Markdown和调用post发布文章 import reimport csdnimport linecacheclass Main(object): # init def __init__(self, file): self.title = '' self.content = '' self.category = '' self.tags = '' # OsChina的系统分类, 设个默认值 self.osChina_sys_category = '编程语言' # CSDN的文章分类, 设个默认值 self.csdn_article_category = '原创' # CSDN的博客分类, 设个默认值 self.csdn_blog_category = '后端' self.read_file(file) # 读取MD中的title, content, self_category, self_tags, osChina_sys_category, csdn_article_category, csdn_blog_category def read_file(self, markdown_file): self.title = linecache.getline(markdown_file, 2).split('title: ')[1].strip('\\n') with open(markdown_file, 'r', encoding='UTF-8') as f: self.content = f.read().split('--&gt;\\n')[1] # 重置文件指针偏移量 f.seek(0) for line in f.readlines(): if re.search('self_category: ', line) is not None: self.category = line.split('self_category: ')[1].strip('\\n') elif re.search('self_tags: ', line) is not None: self.tags = line.split('self_tags: ')[1].strip('\\n') elif re.search('osChina_sys_category: ', line) is not None: self.osChina_sys_category = line.split('osChina_sys_category: ')[1].strip('\\n') elif re.search('csdn_article_category: ', line) is not None: self.csdn_article_category = line.split('csdn_article_category: ')[1].strip('\\n') elif re.search('csdn_blog_category: ', line) is not None: self.csdn_blog_category = line.split('csdn_blog_category: ')[1].strip('\\n')if __name__ == '__main__': md_file = 'auto.md' print(\"Markdown File is \", md_file) timeout = 10 main = Main(md_file) # CSDN csdn = csdn.CSDN() csdn.post(main, timeout) &emsp;&emsp;authorize.py：目前仅实现了用qq进行授权登录的方法 from selenium.webdriver.support.wait import WebDriverWait# QQ授权登录, 使用前提是QQ客户端在线def qq(driver, timeout): # 切换到最新打开的窗口 window_handles = driver.window_handles driver.switch_to.window(window_handles[-1]) print('qq authorize title is ', driver.title) # 切换iframe iframe = WebDriverWait(driver, timeout).until(lambda d: d.find_element_by_id('ptlogin_iframe')) driver.switch_to.frame(iframe) # 点击头像进行授权登录 login = WebDriverWait(driver, timeout).until(lambda d: d.find_element_by_xpath('//*[@id=\"qlogin_list\"]/a[1]')) login.click() &emsp;&emsp;csdn.py：这个是CSDN自动写（发）博客的核心类 import timeimport authorizefrom selenium import webdriverfrom selenium.webdriver.support.ui import Selectfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.common.action_chains import ActionChains# CSDNclass CSDN(object): @staticmethod def post(main, timeout, self_timeout=5): # 1.账号密码 account = 'xxx' password = 'xxx' # 2.跳转登陆 login = 'https://passport.csdn.net/account/login' driver = webdriver.Chrome() driver.get(login) # 3.窗口最大化 driver.maximize_window() # 4.使用账号密码登陆 # login_by_account = WebDriverWait(driver, timeout).until( # lambda d: d.find_element_by_xpath('/html/body/div[3]/div/div/div[2]/div/h3/a')) # login_by_account.click() # time.sleep(self_timeout) # driver.find_element_by_id('username').send_keys(account) # driver.find_element_by_id('password').send_keys(password) # driver.find_element_by_xpath('//*[@id=\"fm1\"]/input[8]').click() # 4.使用QQ授权登录 driver.find_element_by_id('qqAuthorizationUrl').click() driver.close() authorize.qq(driver, timeout) # 5.点击\"写博客\" write_blog = WebDriverWait(driver, timeout).until( lambda d: d.find_element_by_xpath('/html/body/div[1]/div/div/ul/li[3]/a')) write_blog.click() driver.close() window_handles = driver.window_handles driver.switch_to.window(window_handles[-1]) # 6.点击\"开始写作\" start = WebDriverWait(driver, timeout).until( lambda d: d.find_element_by_xpath('//*[@id=\"btnStart\"]')) start.click() # 7.填写标题, 内容 time.sleep(self_timeout) title = driver.find_element_by_xpath('//*[@id=\"txtTitle\"]') title.clear() title.send_keys(main.title) # PS:下面这行代码很重要，卡了好久才解决┭┮﹏┭┮，不信可以试试注释掉这句 ActionChains(driver).click(title).perform() content = driver.find_element_by_xpath('//*[@id=\"wmd-input\"]/div[1]') content.clear() content.send_keys(main.content) # 8.保存草稿 # driver.find_element_by_xpath('//*[@id=\"editorBox\"]/div[2]/div/button[2]').click() # 8.发布文章 driver.find_element_by_xpath('//*[@id=\"editorBox\"]/div[2]/div/button[1]').click() # 9.若第8步选择\"发布文章\", 往下需依次填写标签，个人分类，文章类型，博客分类 tags = main.tags.split('，') add_tag = WebDriverWait(driver, timeout).until(lambda d: d.find_element_by_id('addTag')) for i, tag in enumerate(tags): add_tag.click() tag_input = WebDriverWait(driver, timeout).until( lambda d: d.find_element_by_xpath('//*[@id=\"tagBox\"]/div[' + str(i + 1) + ']/span')) tag_input.send_keys(tag) classify = driver.find_elements_by_class_name('form-check-label') for c in classify: html = c.get_attribute('innerHTML') if main.category in html: c.click() select = Select(driver.find_element_by_id('selType')) select.select_by_visible_text(main.csdn_article_category) select = Select(driver.find_element_by_id('radChl')) select.select_by_visible_text(main.csdn_blog_category) # 10.保存草稿 driver.find_element_by_xpath('//*[@id=\"meditor_box\"]/div[3]/div/div[6]/input[2]').click() # 10.发布文章 # driver.find_element_by_xpath('//*[@id=\"meditor_box\"]/div[3]/div/div[6]/input[3]').click() time.sleep(self_timeout) &emsp;&emsp;CSDN支持账号密码登录，也可以用qq授权的方式，后期只需要扩展authorize.py的功能，就可以支持更多的第三方平台进行授权登录。 运行效果&emsp;&emsp;还是来看看运行效果图吧，这里仅测试保存草稿。 写在最后&emsp;&emsp;在CSDN平台自动写文章的流程大概也就这样，同样这不是唯一的办法，也不敢保证程序可以一直正常运行下去。总而言之，这个花的时间是最多，因为一直卡在了某一点上，不过还好最后还是解决了。本系列还有最后一篇，将介绍如何结合bat脚本在多个平台同时发布文章，以及对系列做一个简单的总结，敬请期待。","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.mariojd.cn/categories/Python/"},{"name":"Selenium","slug":"Python/Selenium","permalink":"https://blog.mariojd.cn/categories/Python/Selenium/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.mariojd.cn/tags/python/"},{"name":"selenium","slug":"selenium","permalink":"https://blog.mariojd.cn/tags/selenium/"},{"name":"csdn","slug":"csdn","permalink":"https://blog.mariojd.cn/tags/csdn/"}]},{"title":"Python + Selenium 自动发布文章（二）：简书","slug":"Python + Selenium 自动发布文章（二）：简书","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2018/05/17/Python + Selenium 自动发布文章（二）：简书/","link":"","permalink":"https://blog.mariojd.cn/2018/05/17/Python + Selenium 自动发布文章（二）：简书/","excerpt":"","text":"写在开始&emsp;&emsp;本篇介绍用Python+Selenium 自动发布简书文章，一些必要的前置准备说明在上篇文章里面有提到，这里就不再重复了。 使用说明&emsp;&emsp;同样的，还是需要先分析下简书写博客的界面（记得设置默认编辑器为Markdown）。 &emsp;&emsp;从上图可以看到，在简书写一篇博客，需要依次选择分类（也就是文集），新建文章，然后填入标题和内容。&emsp;&emsp;结合auto.md的内容进行分析，标题有了，定义在title处；正文内容同样通过匹配--&gt;\\n获取。剩下分类，按规则已经定义在注释里了（self_category）。 代码说明&emsp;&emsp;main.py：程序入口类，主要负责正则匹配解析Markdown和调用post发布文章 import reimport jianshuimport linecacheclass Main(object): # init def __init__(self, file): self.title = '' self.content = '' self.category = '' self.tags = '' # OsChina的系统分类, 设个默认值 self.osChina_sys_category = '编程语言' # CSDN的文章分类, 设个默认值 self.csdn_article_category = '原创' # CSDN的博客分类, 设个默认值 self.csdn_blog_category = '后端' self.read_file(file) # 读取MD中的title, content, self_category, self_tags, osChina_sys_category, csdn_article_category, csdn_blog_category def read_file(self, markdown_file): self.title = linecache.getline(markdown_file, 2).split('title: ')[1].strip('\\n') with open(markdown_file, 'r', encoding='UTF-8') as f: self.content = f.read().split('--&gt;\\n')[1] # 重置文件指针偏移量 f.seek(0) for line in f.readlines(): if re.search('self_category: ', line) is not None: self.category = line.split('self_category: ')[1].strip('\\n') elif re.search('self_tags: ', line) is not None: self.tags = line.split('self_tags: ')[1].strip('\\n') elif re.search('osChina_sys_category: ', line) is not None: self.osChina_sys_category = line.split('osChina_sys_category: ')[1].strip('\\n') elif re.search('csdn_article_category: ', line) is not None: self.csdn_article_category = line.split('csdn_article_category: ')[1].strip('\\n') elif re.search('csdn_blog_category: ', line) is not None: self.csdn_blog_category = line.split('csdn_blog_category: ')[1].strip('\\n')if __name__ == '__main__': md_file = 'auto.md' print(\"Markdown File is \", md_file) timeout = 10 main = Main(md_file) # 简书 jian_shu = jianshu.JianShu() jian_shu.post(main, timeout) &emsp;&emsp;authorize.py：目前仅实现了用qq进行授权登录的方法 from selenium.webdriver.support.wait import WebDriverWait# QQ授权登录, 使用前提是QQ客户端在线def qq(driver, timeout): # 切换到最新打开的窗口 window_handles = driver.window_handles driver.switch_to.window(window_handles[-1]) print('qq authorize title is ', driver.title) # 切换iframe iframe = WebDriverWait(driver, timeout).until(lambda d: d.find_element_by_id('ptlogin_iframe')) driver.switch_to.frame(iframe) # 点击头像进行授权登录 login = WebDriverWait(driver, timeout).until(lambda d: d.find_element_by_xpath('//*[@id=\"qlogin_list\"]/a[1]')) login.click() &emsp;&emsp;jianshu.py：这个是简书自动写（发）博客的核心类 import timeimport authorizefrom selenium import webdriverfrom selenium.webdriver.support.wait import WebDriverWait# 简书class JianShu(object): @staticmethod def post(main, timeout, self_timeout=3): # 1.跳转登陆 login = 'https://www.jianshu.com/sign_in' driver = webdriver.Chrome() driver.get(login) # 2.窗口最大化 driver.maximize_window() # 3.使用QQ授权登录 driver.find_element_by_xpath('/html/body/div[1]/div[2]/div/div/ul/li[3]/a/i').click() driver.close() authorize.qq(driver, timeout) # 4.点击\"写文章\" write_blog = WebDriverWait(driver, timeout).until(lambda d: d.find_element_by_xpath('/html/body/nav/div/a[2]')) write_blog.click() driver.close() window_handles = driver.window_handles driver.switch_to.window(window_handles[-1]) # 5.点击指定分类 classify = WebDriverWait(driver, timeout).until(lambda d: d.find_elements_by_class_name('_3DM7w')) for c in classify: html = c.get_attribute('innerHTML') if main.category in html: c.click() else: # TODO 如果分类不存在，还可以直接新建分类 pass # 6.点击'新建文章' time.sleep(self_timeout) new_article = WebDriverWait(driver, timeout).until( lambda d: d.find_element_by_xpath('//*[@id=\"root\"]/div/div[2]/div[1]/div/div/div/div[1]/i')) new_article.click() article = WebDriverWait(driver, timeout).until( lambda d: d.find_element_by_xpath('//*[@id=\"root\"]/div/div[2]/div[1]/div/div/div/ul/li[1]')) article.click() # 7.填写标题, 内容 time.sleep(self_timeout) title = driver.find_element_by_class_name('_24i7u') title.clear() title.send_keys(main.title) content = driver.find_element_by_id('arthur-editor') content.clear() content.send_keys(main.content) # 8.保存草稿 driver.find_element_by_xpath('//*[@id=\"root\"]/div/div[2]/div[2]/div/div/div/div/ul/li[8]/a').click() # 8.发布文章 # driver.find_element_by_xpath('//*[@id=\"root\"]/div/div[2]/div[2]/div/div/div/div/ul/li[1]/a').click() &emsp;&emsp;其实简书也是支持账号密码登录的，但无奈这种方式登录还有文字验证层，感觉比较棘手，目前也没研究怎么解决，所以先用qq授权的方式登录吧。 运行效果&emsp;&emsp;还是来看看运行效果图吧，这里测试的是保存草稿。 写在最后&emsp;&emsp;在简书自动写文章的思路大概就这样，同样这也不是唯一的办法，根据代码自己做调整即可，网页的结构也可能会改变，故不保证程序可以一直正常运行。最后，下一篇继续介绍如何在CSDN自动写（发）文章。","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.mariojd.cn/categories/Python/"},{"name":"Selenium","slug":"Python/Selenium","permalink":"https://blog.mariojd.cn/categories/Python/Selenium/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.mariojd.cn/tags/python/"},{"name":"selenium","slug":"selenium","permalink":"https://blog.mariojd.cn/tags/selenium/"},{"name":"简书","slug":"简书","permalink":"https://blog.mariojd.cn/tags/简书/"}]},{"title":"自动发布测试文章","slug":"auto-post/auto","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2018/05/16/auto-post/auto/","link":"","permalink":"https://blog.mariojd.cn/2018/05/16/auto-post/auto/","excerpt":"","text":"自动发布&emsp;&emsp;自动发布文章。。 参考地址 happyJared - 博客","categories":[{"name":"测试","slug":"测试","permalink":"https://blog.mariojd.cn/categories/测试/"}],"tags":[{"name":"标签","slug":"标签","permalink":"https://blog.mariojd.cn/tags/标签/"}]},{"title":"Python + Selenium 自动发布文章（一）：开源中国","slug":"Python + Selenium 自动发布文章（一）：开源中国","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2018/05/16/Python + Selenium 自动发布文章（一）：开源中国/","link":"","permalink":"https://blog.mariojd.cn/2018/05/16/Python + Selenium 自动发布文章（一）：开源中国/","excerpt":"","text":"写在开始&emsp;&emsp;还是说说出这个系列的起因吧。之前写完或是修改了Markdown文章，我还分别需要在多个平台进行发布或是更新维护这些内容，这些平台目前包括我的博客、简书、开源中国和CSDN，其实早就想过用比较自动化的形式来解决，无奈有技术、时间、精力等各方面原因的限制。废话不多说吧，直奔今天的主题，本文主要介绍如何用Python和Selenium写（发）开源中国的博客。 准备说明 一定的Python基础知识 一定的Selenium相关知识 开发环境说明：Python v3.6.4，Selenium v3.8.1 PS：Selenium操纵浏览器是依赖于浏览器驱动程序的，下面贴出的是谷歌和火狐浏览器驱动程序的下载地址。 Chrome ( chromedriver ) Firefox ( geckodriver ) 官方下载 官方下载 淘宝镜像 淘宝镜像 备用下载 备用下载 使用说明&emsp;&emsp;下面是示例代码中用到的auto.md文件内容，自动发布文章也还是需要遵循一定的规则，所以以下有几点是必须说明的：&emsp;&emsp;1. [//]: # ()是Markdown注释的一种写法，注释内容写在小括号内；&emsp;&emsp;1.&lt; !-- --&gt;是HTML注释的一种写法，由于Markdown写法的注释有兼容性问题，所以在此调整一下（注意&lt;和!之间实际上是没有空格的，又是为了兼容某些平台的Markdown识别，好想o(╥﹏╥)o）；&emsp;&emsp;2. auto.md中间注释部分的内容，用于匹配获得这几个平台的分类和标签等信息；&emsp;&emsp;3. --&gt;\\n仅用于划分并匹配获取正文部分内容。 ---title: 自动发布测试文章date: 2018-05-16categories: - 测试author: Jared Qiutags: - 标签cover_picture: https://images.unsplash.com/photo-1520095972714-909e91b038e5?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=1110ecf3ce9e4184d4676c54dec0032d&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60top: 1---&lt;!-- self_category: 开源 self_tags: 博客，docker osChina_sys_category: 其他类型 csdn_article_category: 原创 csdn_blog_category: 编程语言--&gt;### 自动发布&amp;emsp;&amp;emsp;自动发布文章。。### 参考地址&gt; [happyJared - 博客](https://blog.mariojd.cn/) &emsp;&emsp;下面的截图是开源中国撰写博客的界面（记得设置默认编辑器为Markdown）。 &emsp;&emsp;从上图可以看到，在开源中国写一篇博客，需要依次录入标题、摘要（可选）、内容、标签（可选）和选择分类（自定义的）、系统分类等信息。&emsp;&emsp;结合auto.md的内容进行分析，相信用过hexo的朋友都比较清楚，标题一般定义在title处；摘要因为是可选的，所以这里先忽略不处理；正文内容我们通过匹配--&gt;\\n就可以获取。剩下标签，自定义分类和系统分类，按规则需要提前定义在注释里，分别对应self_tags,self_category和osChina_sys_category。 代码说明&emsp;&emsp;main.py：程序入口类，主要负责正则匹配解析Markdown和调用post发布文章 import reimport oschinaimport linecacheclass Main(object): # init def __init__(self, file): self.title = '' self.content = '' self.category = '' self.tags = '' # OsChina的系统分类, 设个默认值 self.osChina_sys_category = '编程语言' # CSDN的文章分类, 设个默认值 self.csdn_article_category = '原创' # CSDN的博客分类, 设个默认值 self.csdn_blog_category = '后端' self.read_file(file) # 读取MD中的title, content, self_category, self_tags, osChina_sys_category, csdn_article_category, csdn_blog_category def read_file(self, markdown_file): self.title = linecache.getline(markdown_file, 2).split('title: ')[1].strip('\\n') with open(markdown_file, 'r', encoding='UTF-8') as f: self.content = f.read().split('--&gt;\\n')[1] # 重置文件指针偏移量 f.seek(0) for line in f.readlines(): if re.search('self_category: ', line) is not None: self.category = line.split('self_category: ')[1].strip('\\n') elif re.search('self_tags: ', line) is not None: self.tags = line.split('self_tags: ')[1].strip('\\n') elif re.search('osChina_sys_category: ', line) is not None: self.osChina_sys_category = line.split('osChina_sys_category: ')[1].strip('\\n') elif re.search('csdn_article_category: ', line) is not None: self.csdn_article_category = line.split('csdn_article_category: ')[1].strip('\\n') elif re.search('csdn_blog_category: ', line) is not None: self.csdn_blog_category = line.split('csdn_blog_category: ')[1].strip('\\n')if __name__ == '__main__': md_file = 'auto.md' print(\"Markdown File is \", md_file) timeout = 10 main = Main(md_file) # 开源中国 osChina = oschina.OsChina() osChina.post(main, timeout) &emsp;&emsp;authorize.py：目前仅实现了用qq进行授权登录的方法 from selenium.webdriver.support.wait import WebDriverWait# QQ授权登录, 使用前提是QQ客户端在线def qq(driver, timeout): # 切换到最新打开的窗口 window_handles = driver.window_handles driver.switch_to.window(window_handles[-1]) print('qq authorize title is ', driver.title) # 切换iframe iframe = WebDriverWait(driver, timeout).until(lambda d: d.find_element_by_id('ptlogin_iframe')) driver.switch_to.frame(iframe) # 点击头像进行授权登录 login = WebDriverWait(driver, timeout).until(lambda d: d.find_element_by_xpath('//*[@id=\"qlogin_list\"]/a[1]')) login.click() &emsp;&emsp;oschina.py：这个是开源中国自动写（发）博客的核心类 import authorizefrom selenium import webdriverfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.common.action_chains import ActionChains# 开源中国class OsChina(object): @staticmethod def post(main, timeout): # 1.账号密码 account = 'xxx' password = 'xxx' # 2.跳转登陆 login = 'https://www.oschina.net/home/login' driver = webdriver.Chrome() driver.get(login) # 3.窗口最大化 driver.maximize_window() # 4.使用QQ授权登录 driver.find_element_by_xpath('/html/body/section/div/div[2]/div[2]/div/div[2]/a[4]').click() authorize.qq(driver, timeout) # 4.使用账号密码登陆 # driver.find_element_by_id('userMail').send_keys(account) # driver.find_element_by_id('userPassword').send_keys(password) # driver.find_element_by_xpath('//*[@id=\"account_login\"]/form/div/div[5]/button').click() # 5.移到\"我的空间\", 点击\"我的博客\" my_space = WebDriverWait(driver, timeout).until(lambda d: d.find_element_by_xpath('//*[@id=\"MySpace\"]')) ActionChains(driver).move_to_element(my_space).perform() driver.find_element_by_xpath('/html/body/header/div/div[2]/div/div[2]/div/ul/li[4]/a').click() # 6.点击\"写博客\" write_blog = WebDriverWait(driver, timeout).until( lambda d: d.find_element_by_xpath('/html/body/div/div/div/div/div[1]/div[1]/div[4]/a')) write_blog.click() # 7.选择自定义分类, 系统分类 classify = WebDriverWait(driver, timeout).until(lambda d: d.find_elements_by_class_name('select-opt')) for c in classify: html = c.get_attribute('innerHTML') if main.category in html: if 'span' in html: # 自定义分类 data_value = c.get_attribute('data-value') js = 'document.getElementById(\"self_sort\").value=' + data_value driver.execute_script(js) else: if main.osChina_sys_category == html: # 系统分类 data_value = c.get_attribute('data-value') js = 'document.getElementById(\"sys_sort\").value=' + data_value driver.execute_script(js) # 8.填写标题, 内容和标签 title = driver.find_element_by_xpath('//*[@id=\"title\"]') title.clear() title.send_keys(main.title) content = driver.find_element_by_id('mdeditor') content.clear() content.send_keys(main.content) tags = driver.find_element_by_xpath('//*[@id=\"blog-form\"]/div[2]/div/div[3]/div[1]/div[2]/div[2]/input') tags.clear() tags.send_keys(main.tags) # 9.保存草稿 driver.find_element_by_xpath('//*[@id=\"blog-form\"]/div[3]/div/button[1]').click() # 9.发布文章 # driver.find_element_by_xpath('//*[@id=\"blog-form\"]/div[3]/div/button[2]').click() &emsp;&emsp;从代码注释可以看到，目前支持账号密码和QQ授权两种方式登录，支持保存草稿或发布文章操作。 运行效果&emsp;&emsp;多说无益，来看看运行效果图吧，测试一下保存草稿。 写在最后&emsp;&emsp;总之，在开源中国自动写文章的思路大概就这样，不过这也绝对不是唯一的办法，大家完全可以根据代码自己做调整，而且网页的结构可能会发生改变，这里也不敢保证程序可以一直正常运行下去。好了，下一篇介绍如何在简书自动写（发）文章。","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.mariojd.cn/categories/Python/"},{"name":"Selenium","slug":"Python/Selenium","permalink":"https://blog.mariojd.cn/categories/Python/Selenium/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.mariojd.cn/tags/python/"},{"name":"selenium","slug":"selenium","permalink":"https://blog.mariojd.cn/tags/selenium/"},{"name":"oschina","slug":"oschina","permalink":"https://blog.mariojd.cn/tags/oschina/"}]},{"title":"Chocolatey，Windows下的包管理器","slug":"Chocolatey，Windows下的包管理器","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/05/14/Chocolatey，Windows下的包管理器/","link":"","permalink":"https://blog.mariojd.cn/2018/05/14/Chocolatey，Windows下的包管理器/","excerpt":"","text":"关于Chocolatey&emsp;&emsp;Chocolatey（中文译：巧克力味）是Windows平台下的一款包管理工具，类似于Linux平台的apt-get和yum。第一次接触到Chocolatey的起因是因为在Git官网下载Git的时候，发现这玩意下载的速度超级慢，而且根本没办法一次性顺利下载下来。废话不多说，下面我们来看看怎么安装和使用Chocolatey。 安装Chocolatey&emsp;&emsp;Chocolatey目前不支持类似于.msi这种类型文件的安装包安装，官网提供的是另外两种命令行的方式，一种是CMD，另外一种是PowerShell。Chocolatey的安装可以参考官网的chocolatey安装，但前提是要满足以下几点安装环境要求。 Windows 7+ / Windows Server 2003+ PowerShell v2+ .NET Framework 4+ (the installation will attempt to install .NET 4.0 if you do not have it installed) &emsp;&emsp;PowerShell是cmd的超集。这么理解，cmd能做的事情，PowerShell都能做；cms做不了的事情，PowerShell也都能做。关于PowerShell，点击Windows Power Shell可以了解更多 &emsp;&emsp;提示：Chocolatey的两种安装办法都需要超级管理员权限，不然安装的时候会报错，提示权限不够（默认Chocolatey的安装路径是在C盘下，权限不够会导致某些安装文件无法写入） CMD安装&emsp;&emsp;cmd一般安装在C:\\Windows\\System32下，找到后选择鼠标右键，以管理员身份运行。使用cmd安装Chocolatey的命令如下： @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" &amp;&amp; SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" PowerShell安装&emsp;&emsp;powershell一般安装在C:\\Windows\\System32\\WindowsPowerShell\\v1.0，找到后同样选择鼠标右键，然后以管理员身份运行。使用powershell安装Chocolatey的步骤如下： 运行Get-ExecutionPolicy。如果返回Restricted，则运行Set-ExecutionPolicy AllSigned或Set-ExecutionPolicy Bypass -Scope Process; 运行如下命令 iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) &emsp;&emsp;提示：如果用PowerShell形式安装，最好确认当前PowerShell的版本大于v1.0，否则更推荐大家使用CMD的形式来进行安装。 测试Chocolatey&emsp;&emsp;输入choco，如果出现以下情况，说明安装已经成功。 &emsp;&emsp;提示：如果遇到下面这种错误提示，只需要执行提示内的命令choco feature enable -n useFipsCompliantChecksums即可。 使用Chocolatey&emsp;&emsp;正如你所看到的，Chocolatey是用命令choco来下载、管理、安装和升级包的。下面举几个示例，更多的用法可以查看chocolatey官网。 升级Chocolatey：choco upgrade chocolatey 查看包列表：choco list 安装Git：choco install git 升级Git：choco upgrade git 写在最后&emsp;&emsp;工具的好坏都是因人而异的，所以现在很多东西大家都是褒贬不一的。就拿Chocolatey来说，这个工具对本人来说还是挺好用的，起码解决了升级Git版本的烦恼！ 参考链接 Windows 系统下使用包管理器Chocolateychocolatey 安装报错失败解决办法","categories":[{"name":"Chocolatey","slug":"Chocolatey","permalink":"https://blog.mariojd.cn/categories/Chocolatey/"}],"tags":[{"name":"Chocolatey","slug":"Chocolatey","permalink":"https://blog.mariojd.cn/tags/Chocolatey/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.mariojd.cn/tags/Windows/"},{"name":"开源","slug":"开源","permalink":"https://blog.mariojd.cn/tags/开源/"}]},{"title":"Hexo，使用bat脚本部署文章","slug":"Hexo，使用bat脚本部署文章","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/05/14/Hexo，使用bat脚本部署文章/","link":"","permalink":"https://blog.mariojd.cn/2018/05/14/Hexo，使用bat脚本部署文章/","excerpt":"","text":"写在前面&emsp;&emsp;熟悉Hexo的朋友都知道，写好的Markdown文章应该放到hexo安装目录的source\\_posts文件夹下，然后使用命令hexo g -d或者是hexo d -g进行部署。我在使用Hexo的时候，_post目录其实是关联了我的一个远程Github仓库，我习惯于用小书匠这款编辑器来写MD文章（主要是因为小书匠可以关联使用多个平台的图床服务），写好后也可以直接保存到这个远程仓库中。按以前那种方式，我首先需要在_post目录中pull最新的文章，然后再使用hexo g -d命令来部署。老实说，我承认自己是个懒人，之前也捣腾过用Travis CI来解决hexo自动化部署的问题，但就是一直卡在某一步，然后现在也就搁置了，下来如果弄成功了我会再写一篇文章。今天这篇文章是主角是使用bat脚本来部署文章，在那之前我们先了解一下bat。 关于bat&emsp;&emsp;bat是Windows平台下的一种脚本语言，类似于Linux平台下是shell。下面只是举几个简单的例子，点到为止就好，更多关于bat脚本的语法可以查看这里。 语法 解释 echo 表示打印该命令后的字符，如echo hello执行后会打印“hello” echo off 表示在此语句后所有运行的命令都不显示命令本身 ，但本身会显示 @ 与echo off相象，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行（只能影响当前行） @echo off 组合上两个语法，表示不显示后续执行命令及当前命令 dir c:*.* &gt;a.txt 将c盘文件列表写入a.txt call 用于调用另一个批处理命令或文件（如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令） call c:\\ucdos\\ucdos.bat 调用ucdos.bat脚本 pause 暂停批处理的执行并在屏幕上显示Press any key to continue...的提示，等待用户按任意键后继续 rem 用于注释，也可以用 ::代替 start 调起另外一个窗口执行当前行命令 实战部署&emsp;&emsp;下面贴出的这段代码，也是我用来部署hexo文章的bat脚本（在hexo安装目录下新建deploy.bat，拷贝代码，每次双击运行即可），用Sublime看会比较清晰一点。 :: 左边的两个冒号和rem的效果是类似的，都是注释的作用:: 下面这段代码已经注释，如果去掉rem，那么包含echo off本身和后面的call命令都不会再打印rem @echo off :: call表示在当前窗口执行后面的命令或调用其它脚本call cd source/_postsgit pull origin mastercd ../../hexo g -d 写在最后&emsp;&emsp;所谓好的工具都是为了提高效率而生的，后续本人可能要维护多个平台的文章发表，所以计划用Python写一些自动化发布文章的脚本，然后再结合bat脚本进行调用，感兴趣的小伙伴欢迎继续关注！ 参考文章 Windows Batch ScriptingBAT脚本编写教程Windows .bat 脚本简单用法介绍","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.mariojd.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.mariojd.cn/tags/hexo/"},{"name":"bat脚本","slug":"bat脚本","permalink":"https://blog.mariojd.cn/tags/bat脚本/"},{"name":"开源博客","slug":"开源博客","permalink":"https://blog.mariojd.cn/tags/开源博客/"}]},{"title":"Hexo，自定义博客主题","slug":"Hexo，自定义博客主题","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2018/05/04/Hexo，自定义博客主题/","link":"","permalink":"https://blog.mariojd.cn/2018/05/04/Hexo，自定义博客主题/","excerpt":"","text":"&emsp;&emsp;hexo搭建好后，默认的主题叫 landscape。可是，如果你不想自己的博客就这么干巴巴的，那就去Hexo Themes里面挑一个喜欢的吧，然后换掉它。 &emsp;&emsp;从上图可以看到，Hexo Themes 目前已经提供了超过200个主题供大家选择，这些主题呢都是世界各地热爱开源的小伙伴分享出来的（下一个可能就是你了）。心动了吧，那么改个主题很难吗？答案当然是否定的，只需要下面简单几步，我们就可以拥有一个好看又有个性又有逼格的博客。 挑一个你喜欢的 blog theme，点进去（多数是贡献者的博客网站） 找到当前主题的Github仓库入口（通常情况在博客的正下方），进入Github 克隆当前仓库，放在hexo所在目录的themes文件夹下 修改hexo根目录下的_config.yml文件，找到theme配置项，修改为克隆的主题名称 阅读当前Theme Repository的README.md，参考说明并修改相应配置即可（一般来说每个主题都有自己的_config.yml配置文件，我们只需要关注主题的配置文件即可） PS： 支持安装多个主题，但一次只能使用一个，在根目录下的_config.yml文件中修改切换主题即可。安装和使用主题中遇到的任何问题，可以通过查看主题所在Github仓库的Issues来排查和提问，或者直接联系主题贡献者协助解决吧。 &emsp;&emsp;hexo博客换装，大概就以上这么几步。下来给大家介绍一下我的博客换装过程，有兴趣的可以接着往下看。 &emsp;&emsp;我这个博客用的主题叫MiHo，然后这套主题贡献者博客大概长下面这个样子。 &emsp;&emsp;是不是觉得有点不太一样，这是因为默认的主题还是不太符合我的个性，所以我是有做一点点改造。如果大家接触过前端或者干脆就是做前端开发的，那这些应该都不是难事。好了，下面正式介绍下我是怎么换装的。 Hexo themes，搜索“miho”，点进去 在贡献者博客的正下方，找到了MiHo主题所在的Github Repository 克隆仓库，修改相关配置，主要参考README.md和主题贡献者发布的MiHo-主题安装和配置详情 遇到问题，第一时间查看GitHub Issues和上面那篇文章底部的留言，或者直接联系作者，这总是能快速的帮助我解决 后期个性化调整，主要修改了miho\\source目录下的部分样式文件，以及miho\\layout目录下的部分结构文件 神奇吗？用Hexo，自定义博客主题就这么简单，你还在犹豫什么呢？","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.mariojd.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.mariojd.cn/tags/hexo/"},{"name":"开源博客","slug":"开源博客","permalink":"https://blog.mariojd.cn/tags/开源博客/"},{"name":"hexo themes","slug":"hexo-themes","permalink":"https://blog.mariojd.cn/tags/hexo-themes/"}]},{"title":"Hexo，自定义域名http升级https","slug":"Hexo，自定义域名http升级https","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2018/05/03/Hexo，自定义域名http升级https/","link":"","permalink":"https://blog.mariojd.cn/2018/05/03/Hexo，自定义域名http升级https/","excerpt":"","text":"&emsp;&emsp;数数手指头，我这基于 Hexo + GitHub Page 搭起来的个人博客也有两个月时间了，之前就想过把 http 升级为 https，无奈因为各种原因也就被搁置下来了。今天，我这博客终于升级到 https 了。好东西第一时间是写出来分享，何况这操作真的很简单。 http 升级 https 超简易教程 进入GitHub Page所在的Repository，点击 Settings 在 Options（默认）选项下方找到 GitHub Pages 一栏，如下图所示，勾选 Enforce HTTPS设置即可 &emsp;&emsp;就两步操作，够简单吧！如果你也和我一样，尝试使用过第三方 Cloudflare 域名商的服务，估计你也有跟我一样抓狂过，但 Cloudflare 能为我们自定义的域名提供SSL证书，如果不想这么简单草率，那就留意文章的后续更新吧。 参考链接 GitHub Pages上的自定义域获得对HTTPS的支持Securing your GitHub Pages site with HTTPS低成本将你的网站切换为 HTTPS","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.mariojd.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.mariojd.cn/tags/hexo/"},{"name":"http","slug":"http","permalink":"https://blog.mariojd.cn/tags/http/"},{"name":"https","slug":"https","permalink":"https://blog.mariojd.cn/tags/https/"}]},{"title":"Spring Boot几种启动问题的解决方案","slug":"Spring Boot几种启动问题的解决方案","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/05/02/Spring Boot几种启动问题的解决方案/","link":"","permalink":"https://blog.mariojd.cn/2018/05/02/Spring Boot几种启动问题的解决方案/","excerpt":"","text":"&emsp;&emsp;使用Spring Boot以来，遇到和解决过好几次不同的项目启动问题，大多数事故起于错误的配置和依赖。因此，本文用于汇总这些问题，以及提供相应的解决方案，帮助大家更快的定位和排除故障。 1. Unregistering JMX-exposed beans on shutdown&emsp;&emsp;项目中没有添加spring-boot-starter-web模块依赖，在启动 Application 运行过程中会出现这个错误。 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.11.RELEASE)2018-05-02 18:32:49.445 INFO 33160 --- [ main] cn.mariojd.demo.DemoApplication : Starting DemoApplication on Mario with PID 33160 (started by jd in D:\\IntelliJ IDEA\\projects\\test)2018-05-02 18:32:49.451 INFO 33160 --- [ main] cn.mariojd.demo.DemoApplication : No active profile set, falling back to default profiles: default2018-05-02 18:32:49.542 INFO 33160 --- [ main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@17211155: startup date [Wed May 02 18:32:49 CST 2018]; root of context hierarchy2018-05-02 18:32:50.115 INFO 33160 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2018-05-02 18:32:50.128 INFO 33160 --- [ main] cn.mariojd.demo.DemoApplication : Started DemoApplication in 1.01 seconds (JVM running for 1.83)... end SpringApplication.run()2018-05-02 18:32:50.129 INFO 33160 --- [ Thread-2] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@17211155: startup date [Wed May 02 18:32:49 CST 2018]; root of context hierarchy2018-05-02 18:32:50.130 INFO 33160 --- [ Thread-2] o.s.j.e.a.AnnotationMBeanExporter : Unregistering JMX-exposed beans on shutdown &emsp;&emsp;解决方案，引入spring-boot-starter-web模块 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; &emsp;&emsp;网上大多数的解决方案是通过添加spring-boot-starter-tomcat依赖来解决，但实测证明此方法不可行。 2. Cannot determine embedded database driver class for database type NONE&emsp;&emsp;项目中添加了spring-boot-starter-data-jpa模块依赖，而且没有配置数据源连接信息的情况下，启动 Application 过程中会出现该错误，原因是Spring Boot在启动时会自动注入数据源和配置JPA。 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.11.RELEASE)2018-05-02 19:49:13.640 INFO 37652 --- [ main] cn.mariojd.demo.DemoApplication : Starting DemoApplication on Mario with PID 37652 (started by jd in D:\\IntelliJ IDEA\\projects\\test)2018-05-02 19:49:13.643 INFO 37652 --- [ main] cn.mariojd.demo.DemoApplication : No active profile set, falling back to default profiles: default2018-05-02 19:49:13.692 INFO 37652 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@62fdb4a6: startup date [Wed May 02 19:49:13 CST 2018]; root of context hierarchy2018-05-02 19:49:15.150 INFO 37652 --- [ main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$4ad697b] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)2018-05-02 19:49:15.433 INFO 37652 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2018-05-02 19:49:15.460 INFO 37652 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]2018-05-02 19:49:15.461 INFO 37652 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.292018-05-02 19:49:15.564 INFO 37652 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2018-05-02 19:49:15.564 INFO 37652 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1876 ms2018-05-02 19:49:15.679 INFO 37652 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: 'dispatcherServlet' to [/]2018-05-02 19:49:15.682 INFO 37652 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'characterEncodingFilter' to: [/*]2018-05-02 19:49:15.682 INFO 37652 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]2018-05-02 19:49:15.682 INFO 37652 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'httpPutFormContentFilter' to: [/*]2018-05-02 19:49:15.683 INFO 37652 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'requestContextFilter' to: [/*]2018-05-02 19:49:15.717 WARN 37652 --- [ main] ationConfigEmbeddedWebApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration': Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration$Tomcat.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.tomcat.jdbc.pool.DataSource]: Factory method 'dataSource' threw exception; nested exception is org.springframework.boot.autoconfigure.jdbc.DataSourceProperties$DataSourceBeanCreationException: Cannot determine embedded database driver class for database type NONE. If you want an embedded database please put a supported one on the classpath. If you have database settings to be loaded from a particular profile you may need to active it (no profiles are currently active).2018-05-02 19:49:15.719 INFO 37652 --- [ main] o.apache.catalina.core.StandardService : Stopping service [Tomcat]2018-05-02 19:49:15.765 INFO 37652 --- [ main] utoConfigurationReportLoggingInitializer : Error starting ApplicationContext. To display the auto-configuration report re-run your application with 'debug' enabled.2018-05-02 19:49:15.791 ERROR 37652 --- [ main] o.s.b.d.LoggingFailureAnalysisReporter : ***************************APPLICATION FAILED TO START***************************Description:Cannot determine embedded database driver class for database type NONEAction:If you want an embedded database please put a supported one on the classpath. If you have database settings to be loaded from a particular profile you may need to active it (no profiles are currently active).Process finished with exit code 1 解决方案1，移除spring-boot-starter-data-jpa模块依赖； 解决方案2，将启动类注解@SpringBootApplication修改如下； @SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,DataSourceTransactionManagerAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;) 解决方案3，在配置文件中添加数据库连接信息。spring: datasource: url: xxx username: xxx password: xxx","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.mariojd.cn/tags/Spring-Boot/"}]},{"title":"Spring Boot中初始化资源的几种方式","slug":"Spring Boot中初始化资源的几种方式","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/05/02/Spring Boot中初始化资源的几种方式/","link":"","permalink":"https://blog.mariojd.cn/2018/05/02/Spring Boot中初始化资源的几种方式/","excerpt":"","text":"&emsp;&emsp;假设有这么一个需求，要求在项目启动过程中，完成线程池的初始化，加密证书加载等功能，你会怎么做？如果没想好答案，请接着往下看。今天介绍几种在Spring Boot中进行资源初始化的方式，帮助大家解决和回答这个问题。 CommandLineRunner 定义初始化类 MyCommandLineRunner 实现 CommandLineRunner 接口，并实现它的 run() 方法，在该方法中编写初始化逻辑 注册成Bean，添加 @Component注解即可 示例代码如下： @Componentpublic class MyCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(\"...init resources by implements CommandLineRunner\"); &#125; &#125; &emsp;&emsp;实现了 CommandLineRunner 接口的 Component 会在所有 Spring Beans 初始化完成之后， 在 SpringApplication.run() 执行之前完成。下面通过加两行打印来验证我们的测试。 @SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; System.out.println(\"... start SpringApplication.run()\"); SpringApplication.run(DemoApplication.class, args); System.out.println(\"... end SpringApplication.run()\"); &#125; &#125; &emsp;&emsp;控制台打印结果如下。 ... start SpringApplication.run() . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.11.RELEASE)。。。。。。（此处省略一堆打印信息）2018-05-02 17:01:19.700 INFO 21236 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)...init resources by implements CommandLineRunner2018-05-02 17:01:19.708 INFO 21236 --- [ main] cn.mariojd.demo.DemoApplication : Started DemoApplication in 2.282 seconds (JVM running for 3.125)... end SpringApplication.run() ApplicationRunner 定义初始化类 MyApplicationRunner 实现 ApplicationRunner 接口，并实现它的 run() 方法，在该方法中编写初始化逻辑 注册成Bean，添加 @Component注解即可 示例代码如下： @Componentpublic class MyApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments applicationArguments) throws Exception &#123; System.out.println(\"...init resources by implements ApplicationRunner\"); &#125;&#125; &emsp;&emsp;可以看到，通过实现 ApplicationRunner 接口，和通过实现 CommandLineRunner 接口都可以完成项目的初始化操作，实现相同的效果。两者之间唯一的区别是 run() 方法中自带的形参不相同，在 CommandLineRunner 中只是简单的String... args形参，而 ApplicationRunner 则是包含了 ApplicationArguments 对象，可以帮助获得更丰富的项目信息。 @Order&emsp;&emsp;如果项目中既有实现了 ApplicationRunner 接口的初始化类，又有实现了 CommandLineRunner 接口的初始化类，那么会是哪一个先执行呢？测试告诉我们，答案是实现了 ApplicationRunner 接口的初始化类先执行，我想这点倒是不需要大家过分去关注为什么。但如果需要改变两个初始化类之间的默认执行顺序，那么使用 @Order 注解就可以帮助我们解决这个问题。 @Component@Order(1)public class MyCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(\"...init resources by implements CommandLineRunner\"); &#125;&#125; @Component@Order(2)public class MyApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments applicationArguments) throws Exception &#123; System.out.println(\"...init resources by implements ApplicationRunner\"); &#125;&#125; &emsp;&emsp;最终，控制台中打印如下。通过控制台输出我们发现， @Order 注解值越小，该初始化类也就越早执行。 。。。。。。（此处省略一堆打印信息）2018-05-02 17:27:31.450 INFO 28304 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)...init resources by implements CommandLineRunner...init resources by implements ApplicationRunner2018-05-02 17:27:31.453 INFO 28304 --- [ main] cn.mariojd.demo.DemoApplication : Started DemoApplication in 2.086 seconds (JVM running for 2.977) @PostConstruct&emsp;&emsp;使用 @PostConstruct 注解同样可以帮助我们完成资源的初始化操作，前提是这些初始化操作不需要依赖于其它Spring beans的初始化工作。 &emsp;&emsp;可以看到 @PostConstruct 注解是用在方法上的，写一个方法测试一下吧。 @PostConstructpublic void postConstruct() &#123; System.out.println(\"... PostConstruct\");&#125; &emsp;&emsp;启动项目，控制台中最终打印如下。 ... start SpringApplication.run() . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.11.RELEASE)。。。。。。（此处省略一堆打印信息）... PostConstruct。。。。。。（此处省略一堆打印信息）2018-05-02 17:40:22.300 INFO 29796 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)...init resources by implements CommandLineRunner...init resources by implements ApplicationRunner2018-05-02 17:40:22.303 INFO 29796 --- [ main] cn.mariojd.demo.DemoApplication : Started DemoApplication in 2.387 seconds (JVM running for 3.267)... end SpringApplication.run() 文末小结&emsp;&emsp;综上，使用 @PostConstruct 注解进行初始化操作的顺序是最快的，前提是这些操作不能依赖于其它Bean的初始化完成。通过添加 @Order 注解，我们可以改变同层级之间不同Bean的加载顺序。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.mariojd.cn/tags/Spring-Boot/"}]},{"title":"docker + anoyi-blog 打造专属个人“简书”博客","slug":"docker + anoyi-blog 打造专属个人“简书”博客","date":"un55fin55","updated":"un22fin22","comments":true,"path":"2018/04/27/docker + anoyi-blog 打造专属个人“简书”博客/","link":"","permalink":"https://blog.mariojd.cn/2018/04/27/docker + anoyi-blog 打造专属个人“简书”博客/","excerpt":"","text":"[//]: # ( - oschina: - categoryName: 开源 - sysCategoryName: 其他类型 - tags: 博客，docker - jianshu: - csdn: ) 写在前面&emsp;&emsp;anoyi-blog，一款有趣的开源个人博客建站工具，简单梳理下分享给大家。该工具基于 Docker， 可快速搭建和一键生成个人博客，用于实时解析简书文章、作者信息，专为个性化而生！ Docker命令docker run -d --name myblog \\-e JIANSHU_ID=000a530f461c \\-e WEB_NAME=happyJared \\-e GITHUB=\"https://github.com/happyjared\" \\-e GITLAB=\"https://github.com/happyjared\" \\-e QQ=12345678 \\-e ICP=粤ICP备12345678号 \\-e REWARD_IMAGES=\"https://upload.jianshu.io/users/qrcodes/9709135/myweixin.png?imageMogr2/auto-orient/strip|imageView2/1/w/84/h/84\" \\-e REWARD_DESC=\"赞赏支持\" \\-e BLOG_TITLE=\"博客标题\" \\-e BLOG_DESC=\"博客描述\" \\-p 20184:8080 registry.cn-hangzhou.aliyuncs.com/anoy/blog &emsp;&emsp;docker run之后，访问 http://localhost:20184/ 可查看生成的博客，映射其他端口可配置： -p {port}:8080 配置说明 变量 说明 示例 JIANSHU_ID 简书ID https://www.jianshu.com/u/000a530f461c， 点击“简书”-&gt;“我的主页”，这里只需要取000a530f461c即可 WEB_NAME 网站名称 happyJared GITHUB Github 地址 https://github.com/happyjared GITLAB Gitlab 地址 https://github.com/happyjared QQ QQ 号（用于发起聊天沟通） 12345678 ICP ICP 备案号 粤ICP备12345678号 REWARD_IMAGES 打赏二维码图片链接地址 多个图片可用 , 分隔 REWARD_DESC 打赏提示语 赞赏支持 BLOG_TITLE 博客标题 博客标题 BLOG_DESC 博客描述 博客描述 DING_TALK 钉钉机器人 API 地址 参考钉钉自定义机器人 示例：-e DING_TALK=”https://oapi.dingtalk.com/robot/send?access_token=b1586fba8caf2c98bf6f1174b4ec57c75941553a15a75c437422f55fc1b76cd1“ 简单分析 &emsp;&emsp;查看启动日志，通过运行命令docker logs myblog，可以看到 anoyi-blog 是基于 Spring Bootv2.0.0.RELEASE开发的，使用了 Undertow 作为Web服务器 &emsp;&emsp;运行命令docker inspect anoyi-blog，可以看到完整的启动脚本 java -jar -server /app.jar --jianshu.user-id=$JIANSHU_ID --custom.web-name=$WEB_NAME --custom.github-url=$GITHUB --custom.gitlab-url=$GITLAB --custom.qq=$QQ --custom.icp=$ICP --custom.reward-images=$REWARD_IMAGES --custom.reward-desc=$REWARD_DESC --custom.blog-title=$BLOG_TITLE --custom.blog-desc=$BLOG_DESC --custom.ding-talk=$DING_TALK 写在最后&emsp;&emsp;可以看到，利用 docker + anoyi-blog 来打造个人简书博客还是很方便的。但相比于两大静态博客主流框架：jekyll 和 hexo ，anoyi-blog 在可定制化方面确实显得较为欠缺。 参考地址 开源博客 ANOYI-BLOG 使用指南anoy/blog - 阿里云镜像","categories":[{"name":"开源","slug":"开源","permalink":"https://blog.mariojd.cn/categories/开源/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.mariojd.cn/tags/docker/"},{"name":"博客","slug":"博客","permalink":"https://blog.mariojd.cn/tags/博客/"}]},{"title":"Jmeter 压测 ws(s)","slug":"Jmeter压测 ws(s)","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2018/04/25/Jmeter压测 ws(s)/","link":"","permalink":"https://blog.mariojd.cn/2018/04/25/Jmeter压测 ws(s)/","excerpt":"","text":"&emsp;&emsp;上一篇Jmeter压测http(s)介绍了如何使用Jmeter压测常规的web服务接口。本文将继续演示如何使用Jmeter对ws(s)进行压力测试。 &emsp;&emsp;有过Socket相关开发经验的人应该都不会陌生，ws协议就是WebSocket协议，而wss对应就是在SSL上运行的WebSocket协议。有关WebSocket的知识，这里不做过多说明，有兴趣可以看看本人写的另外一篇文章：记录一次迁移wss WebSocket的事故。 配置环境&emsp;&emsp;由于JMeter需要添加几个扩展Jar包后方可支持ws测试，所以我们需要配置相关的测试环境，以下是这些jar包的下载地址。 官方下载 备用下载 &emsp;&emsp;将下载好的Jar包放到JMeter的lib\\ext目录下即可。 ws测试&emsp;&emsp;启动Jmeter后，右键依次选择 “测试计划” -&gt; “添加” -&gt; “Threads(Users)” -&gt; “线程组” -&gt; “Sampler” -&gt; “WebSocket Sampler”。 选项说明： WebServer Server Name or IP：目标WebSocket服务器所在地址或名称 Port Number：WebSocket 服务监听端口（http和ws一般是80端口，https和wss一般是433端口) Timeout（单位：毫秒） Connection：连接等待完成的最长时间 Response：消息响应的最大等待时间 WebSocket Request Implementation：目前仅支持RFC6455(v13) ，这也是最新版的WebSocket协议标准 Protocol：WebSocket标识，ws或者wss Streaming Connection：用于TCP会话是否需要保持。如果勾上表示连接会一直存在，否则在第一次响应后该连接就会被关闭 Request data：请求要发送的数据 Path：WebSocket端点路径 &emsp;&emsp;为了方便，下面以一个在线的WebSocket网站来开展测试。分别在Server Name or IP一栏中输入：echo.websocket.org，在Request data一栏中输入：Send test。启动测试计划，得到如下响应结果。 wss测试&emsp;&emsp;相比于ws测试，wss的测试也仅需修改两处地方。分别将Port Number修改为：443，以及将Protocol修改为：wss。启动测试计划后，我们同样可以得到系统的正常响应。 写在最后&emsp;&emsp;结合“函数助手”或者“CVS数据文件”的方式，我们同样可以模拟实现不同的用户，发送不同的请求参数。有关于JMeter的内容到这就告一段落了，后续如果还有其它的补充，我会及时的更新上去。","categories":[{"name":"Jmeter","slug":"Jmeter","permalink":"https://blog.mariojd.cn/categories/Jmeter/"}],"tags":[{"name":"Jmeter","slug":"Jmeter","permalink":"https://blog.mariojd.cn/tags/Jmeter/"},{"name":"ws(s)","slug":"ws-s","permalink":"https://blog.mariojd.cn/tags/ws-s/"},{"name":"压测工具","slug":"压测工具","permalink":"https://blog.mariojd.cn/tags/压测工具/"}]},{"title":"Jmeter 压测 http(s)","slug":"Jmeter压测 http(s)","date":"un22fin22","updated":"un33fin33","comments":true,"path":"2018/04/24/Jmeter压测 http(s)/","link":"","permalink":"https://blog.mariojd.cn/2018/04/24/Jmeter压测 http(s)/","excerpt":"","text":"&emsp;&emsp;上一篇文章关于Jmeter介绍了Jmeter入门相关的知识。本文是实战篇，讲讲如何使用Jmeter对Http(s)进行压力测试。 Http测试测试一&emsp;&emsp;首先，添加 “线程组”，选择 “添加” -&gt; “Sampler” -&gt; “HTTP请求”。其次，分别添加 “查看结果树”，“聚合报告”，“图形结果”等，用于查看测试结果。 &emsp;&emsp;配置 “HTTP请求”，对应上图中的 “jmeter测试1”。这里配置Get请求，测试本地8080端口下的jmeter/test1接口地址，具体的Http配置及测试代码请参考如下。 @RequestMapping(\"jmeter\")@RestControllerpublic class HttpController &#123; private AtomicInteger atomicInteger = new AtomicInteger(0); @GetMapping(\"test1\") public Map&lt;String, Object&gt; test1() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(1); int decrementAndGet = atomicInteger.incrementAndGet(); System.out.println(\"decrementAndGet = \" + decrementAndGet); map.put(\"atomicInteger\", decrementAndGet); return map; &#125; &#125; &emsp;&emsp;配置好后，点击绿色三角图标即可启动线程组，线程组的配置如下。 &emsp;&emsp;启动测试请求后，响应结果如下，这是模拟1s内发起200次的请求。 测试二&emsp;&emsp;一般而言，测试都需要尽可能的模拟真实用户。因此，通过传递不同的请求参数，来模拟不同的用户进行请求是必不可少的。接下来使用 “函数助手的” 方式，告诉大家如何模拟不同的用户进行压力测试。 &emsp;&emsp;案例场景：模拟10个用户发起POST请求，请求地址jmeter/test2，要求在Http请求头中自定义请求头 Authorization ，不同用户对应的自定义请求头参数值不同。 1. 使用函数助手添加请求头参数 CSV，即Comma Separate Values，这种文件格式经常用来作为不同程序之间的数据交互格式。具体文件格式：每条记录占一行，以逗号为分隔符，逗号前后的空格会被忽略。字段中包含有逗号，该字段必须用双引号括起来；字段中包含有换行符，该字段必须用双引号括起来；字段前后包含有空格，该字段必须用双引号括起来；字段中的双引号用两个双引号表示；字段中如果有双引号，该字段必须用双引号括起来。 &emsp;&emsp;在本地创建test2.cvs（如：G:\\TEST\\test2.cvs），添加10个用户对应的Authorization值（假设是：1 ~ 10），使用函数助手进行添加。 2. 配置 “HTTP信息头管理器” &emsp;&emsp;如上图所示，分别设置 Content-Type:application/json和Authorization:${__CSVRead(G:\\TEST\\test2.cvs,0)} 3. 模拟用户请求进行测试@RequestMapping(\"jmeter\")@RestControllerpublic class HttpController &#123; @PostMapping(\"test2\") public Map&lt;String, Object&gt; test2(HttpServletRequest request) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(1); String authorization = request.getHeader(\"Authorization\"); map.put(\"authorization\", authorization); return map; &#125;&#125; &emsp;&emsp;启动测试后，响应结果如下。 测试三&emsp;&emsp;案例场景：使用配置元件 “CSV数据文件” 的方式，模拟10个用户发起PUT请求，请求地址jmeter/test3，要求不同用户对应请求参数reqId的值不同。 1. 使用“CSV数据文件”添加请求参数&emsp;&emsp;在本地创建test2.cvs（如：G:\\TEST\\test2.cvs），添加10个用户对应的reqId值（假设是：1 ~ 10）。 2. 配置 “HTTP信息头管理器” &emsp;&emsp;如上图所示，通过在请求路径使用占位符${}来读取“CSV数据文件”中对应的配置参数和值。注意，占位符内的参数名称要保持与配置一致。 3. 模拟用户请求进行测试@RequestMapping(\"jmeter\")@RestControllerpublic class HttpController &#123; @PutMapping(\"test3\") public Map&lt;String, Object&gt; test3(@RequestParam int reqId) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(1); System.out.println(\"id = [\" + reqId + \"]\"); map.put(\"id\", reqId); return map; &#125;&#125; &emsp;&emsp;启动测试后，响应结果如下。 Https测试&emsp;&emsp;为了方便，关于https的测试将选取网上站点进行，如我的简书主页，参考如下。 写在最后&emsp;&emsp;关于http(s)这块的测试到这就介绍完了，本文重点部分就是学习两种实现参数化的方式。JMeter作为一款压测工具，我们只需要熟悉之后再多加练习，便可以基本掌握。下来我将继续梳理如何使用JMeter进行ws(s)测试，欢迎关注。","categories":[{"name":"Jmeter","slug":"Jmeter","permalink":"https://blog.mariojd.cn/categories/Jmeter/"}],"tags":[{"name":"Jmeter","slug":"Jmeter","permalink":"https://blog.mariojd.cn/tags/Jmeter/"},{"name":"压测工具","slug":"压测工具","permalink":"https://blog.mariojd.cn/tags/压测工具/"},{"name":"http(s)","slug":"http-s","permalink":"https://blog.mariojd.cn/tags/http-s/"}]},{"title":"关于Jmeter","slug":"关于Jmeter","date":"un11fin11","updated":"un33fin33","comments":true,"path":"2018/04/23/关于Jmeter/","link":"","permalink":"https://blog.mariojd.cn/2018/04/23/关于Jmeter/","excerpt":"","text":"Apache JMeter The Apache JMeter™ application is open source software, a 100% pure Java application designed to load test functional behavior and measure performance. It was originally designed for testing Web Applications but has since expanded to other test functions. &emsp;&emsp; 关于JMeter，这里不做过多说明，更多介绍可以查看官网。我们只需要知道这是一款用Java开发的压力测试工具，可以模拟对服务器的请求来测试它们的负载强度，分析不同压力类型下的整体性能。 1. 下载安装 Download Apache JMeter &emsp;&emsp; 注意： JMeter运行依赖于Java环境，所以请提前装好这些环境，并配置全局的环境变量。从上图我们可以得知，JMeter4.0+更是需要Java8或者Java9环境。如果不需要了解源码，这里我们只需要选择下载“Binaries”一栏中的.tgz或.zip包即可，然后解压即可。 2. 运行JMeter4.0 &emsp;&emsp;进入bin目录下，Windows平台双击 “ApacheJMeter.jar” 或 “jmeter.bat” 即可，Linux下请启动 “jmeter.sh” 脚本。 &emsp;&emsp;这是JMeter4.0的主界面，可以看到这是用Java Swing写的GUI。 3. JMeter4.0简单介绍 &emsp;&emsp;顶部导航栏中。最左边的 File 选项，可用于新建、打开（最近）和保存测试计划。重点关注第四个选项 Run，一般编写完测试计划后，我们可以在此下拉选择启动（或中断），或者可以点击第二栏中间部位的“绿色右三角标”进行启动。再往右边一点，可以看到有两个带有“扫帚”的图案，这两个是用来清除测试结果的。 在Test plan（测试计划）处，右键选择 Add，然后在 Threads(Users)中选择 Thread Group（添加线程组），接下来简单介绍一下线程组中的部分核心功能。 线程属性 线程数：模拟多少并发用户，就设置多大的数值 Ramp-Up Period (in seconds)：并发访问的时间范围大小 循环次数：执行多少次循环（勾选“永远”后线程组将一直执行） 示例：线程数（1000），Ramp-Up Period（3），循环次数（2）解释：在3秒内模拟共1000次的用户并发请求，并循环执行2次 调度器配置（勾选“调度器”选项开启） 持续时间（秒）：线程组执行的总时长 启动延迟（秒）：执行线程组后，延迟真正开始请求的时间，默认启动后立刻执行 Http请求：用于配置Http请求的信息 配置元件 CVS数据文件设置：通过导入CVS文件，模拟不同的请求参数进行接口压测（PS：顶部导航栏 “选项” -&gt; “函数助手” 也可以实现类似的功能，后续实战将进行一一介绍） Http信息头管理：设置Http请求头参数等 Http Cookie 管理器：设置Cookie信息 察看结果树：用于查看Http请求响应结果信息 聚合报告：用于查看报告分析等信息 写在最后 &emsp;&emsp;注意，线程组的配置似乎是需要按顺序进行的，否则可能会出现某些配置不生效的情况。下来我会进行实战压测演示，模拟对Http(s)和ws(s)接口的请求，欢迎关注。最后，附上示例的JMeter配置，下载后（无法自动下载，请点击右键，选择另存为即可），在JMeter中选择导入即可。 demo.jmx","categories":[{"name":"Jmeter","slug":"Jmeter","permalink":"https://blog.mariojd.cn/categories/Jmeter/"}],"tags":[{"name":"Jmeter","slug":"Jmeter","permalink":"https://blog.mariojd.cn/tags/Jmeter/"},{"name":"压测工具","slug":"压测工具","permalink":"https://blog.mariojd.cn/tags/压测工具/"}]},{"title":"记录一次迁移wss WebSocket的事故","slug":"记录一次迁移wss WebSocket的事故","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2018/04/21/记录一次迁移wss WebSocket的事故/","link":"","permalink":"https://blog.mariojd.cn/2018/04/21/记录一次迁移wss WebSocket的事故/","excerpt":"","text":"&emsp;&emsp;今天是2018年04月21日。 &emsp;&emsp;过去的这一个多月里，我的工（开）作（发）任务转战回了游戏。短短的一个月里，催着输出两款h5游戏，再加上对接、联调，想想真是够辛（ku）苦（bi）的。本人负责后端，也就是服务端这块的游戏主流程输出。去年下半年，在前任大佬的带领下，做过一两款棋牌类的手游，虽然目前的运营状况不太乐观。不过好在，过去学的那点皮毛也还没丢光，所以这次写h5后端总体还算顺畅。至于怎么用Java来写游戏，下来如果有时间会整理下这块的思路和知识。 关于WebSocket，维基百科是这样介绍的： &emsp;&emsp; 以前，很多网站为了实现实时推送技术，所用的技术都是轮询。轮询是在特定的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端。这种传统的模式带来的缺点很明显，即浏览器需要不断的向服务器发出请求，然而HTTP请求包含较多的请求头信息，而其中真正有效的数据只是很小的一部分，显然这样会浪费很多的带宽等资源。在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。&emsp;&emsp; WebSocket是一种在单个TCP连接上进行全双工通讯的协议，使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。 &emsp;&emsp;WebSocket 协议在2008年诞生，2011年成为国际标准，现在几乎所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 &emsp;&emsp;简单来说，WebSocket减少了客户端与服务器端建立连接的次数，减轻了服务器资源的开销，只需要完成一次HTTP握手。整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直与客户端保持连接，直到双方发起关闭请求，同时由原本的客户端主动询问，转换为服务器有信息的时候推送。所以，它能做实时通信（聊天室、直播间等），其他特点还包括： 建立在 TCP 协议之上，服务器端的实现比较容易 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器 数据格式比较轻量，性能开销小，通信高效 可以发送文本，也可以发送二进制数据 没有同源限制，客户端可以与任意服务器通信 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL &emsp;&emsp;差点就跑题了。这不，由于业务需求，上头要求新出的h5游戏要配上Https。无奈，公司小，没有专业的运维人员，所以只能由我们这些开发“猿”顶上了，以为会很顺畅，但一连串的问题没想到也才刚刚开始。因此本文，就是用来记录这些踩过的“坑”，希望可以让后人少走点弯路。 1. 申领证书&emsp;&emsp; 公有云服务器上，一般大家都习惯使用Nginx来做反向代理。首先，配置Https，需要我们到专业的CA机构去申领证书，这个证书大多数情况下都是要钱的，但其实也有免费的（有效期1年），例如利用国内的阿里云或者腾讯云就可以很方便的申请这证书。 &emsp;&emsp; - 阿里云 - Https证书申请&emsp;&emsp; - 腾讯云 - Https证书申请 阿里云Https证书申请 &emsp;&emsp;PS： 通过阿里云申领免费版SSL证书有点套路，藏得有点深。点击以上链接进入后，如果在“证书类型”一栏中没找到“免费型DV SSL”，那么请依次点击第三栏的“选择品牌”中的“Symantec”，然后回到第一栏的“证书类型”，点击出现的第三个选项“增强型OV SSL”，之后就会在“证书类型”中出现我们需要的第二项：“免费型DV SSL”。 腾讯云Https证书申请 &emsp;&emsp;确认申领、购买之后，下来还需要绑定我们的域名（注意：免费型的SSL证书一般仅支持绑定一个一级域名或者子域名，通配符的证书一般是需要花钱的），以及进行域名身份验证等操作。等这两步都完成之后，只需要等待CA机构扫描认证之后，我们就可以拿到真正的证书了。 2. 配置Https&emsp;&emsp;下载好证书压缩包并解压之后，一般里面有IIS、Apache和Nginx三款主流服务器的ssl证书，这里我们也仅需要Nginx的证书。首先，将证书里Nginx文件夹下的1_{域名}bundle.crt 和2{域名}.key复制到我们服务器上的指定位置（假设在/root/ssl/下面）。基于Nginx的Https配置还是比较简单的，参考如下。 server &#123;# listen 80; #如果需要同时支持http和https listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate &quot;/root/ssl/1_&#123;域名&#125;_bundle.crt&quot;; ssl_certificate_key &quot;/root/ssl/2_&#123;域名&#125;.key&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; server_name &#123;域名&#125;; location / &#123; proxy_pass http://localhost:&#123;代理端口&#125;; &#125; &#125; &emsp;&emsp;附：下面是开启Nginx的Gzip压缩的配置，有需要的也可以参考。 http &#123; gzip on; gzip_disable &quot;msie6&quot;; gzip_min_length 1k; gzip_vary on; gzip_proxied any; gzip_comp_level 6; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_types application/font-woff text/plain application/javascript application/json text/css application/xml text/javascript image/jpg image/jpeg image/png image/gif image/x-icon; server &#123; # 这里是server相关的配置 &#125;&#125; 3. 事故现场&emsp;&emsp;完成以上步骤后，按道理来说，h5游戏确实可以通过https的形式来打开了，简单测试后的确没啥问题，然后大家也就这样愉快的下班了。不过正如“墨菲定律”所说的：“凡事只要有可能出错，那就一定会出错”。果不其然，一段时间后，测试就在群里反馈，某段时间后h5游戏就无法加载正常进行下去了，一看时间，正是配完Https之后开始出现的问题。没办法，于是连忙打开电脑，开始排查解决问题，直觉告诉我要先打开浏览器的控制面板，果不其然，立刻发现了问题。 Mixed Content: The page at ‘https://{域名}.com/‘ was loaded over HTTPS, but attempted to connect to the insecure WebSocket endpoint ‘ws://{ip}:{port}/‘. This request has been blocked; this endpoint must be available over WSS.Uncaught DOMException: Failed to construct ‘WebSocket’: An insecure WebSocket connection may not be initiated from a page loaded over HTTPS. &emsp;&emsp;好家伙，这种情况，毫无疑问我们就需要使用 wss:// 安全协议了，于是立即联系h5客户端，把连接服务端webscoket的形式由ws:// 改为 wss:// 。本以为这样就解决了，没想到一段时间后下一个问题又来了。 扩展：关于 ws 和 wss WebSocket可以使用 ws 或 wss 来作为统一资源标志符，类似于 HTTP 或 HTTPS。其中 ，wss 表示在 TLS 之上的 WebSocket，相当于 HTTPS。默认情况下，WebSocket的 ws 协议基于Http的 80 端口；当运行在TLS之上时，wss 协议默认是基于Http的 443 端口。说白了，wss 就是 ws 基于 SSL 的安全传输，与 HTTPS 一样样的道理。所以，如果你的网站是 HTTPS 协议的，那你就不能使用 ws:// 了，浏览器会 block 掉连接，和 HTTPS 下不允许 HTTP 请求一样。 &emsp;&emsp;h5客户端改成wss连接后，测试发现还是无法正常游戏。无奈，再次打开浏览器面板，果然，又看到一个新的问题。 WebSocket connection to ‘wss://{ip}:{port}/‘ failed: Error in connection establishment: net::ERR_SSL_PROTOCOL_ERROR &emsp;&emsp;之前在Http的情况下，客户端一直是用ip+port的形式来连接服务端，当然了也不会出现什么问题。很明显，在更改成Https后，若还是以这种方式连接服务端，浏览器就会报 SSL 协议错误，这很明显就是证书的问题。如果这时候还用 IP + 端口号 的方式连接 WebSocket ，是根本就没有证书存在的（即使我们在Nginx配置了SSL证书，但这种方式其实是不会走Nginx代理的），所以在生成环境下，更推荐大家用域名的方式来连接。于是，立刻又联系前端，再一次做更改，修改为 wss://{域名}/ 进行连接。我以为这样就真的解决了，没想到还是too young too simple，没一会下个问题又来了，测试反馈的结果还是不可以，第三次打开浏览器控制面板，果然又是一个新的错误信息。 WebSocket connection to ‘wss://{域名}/‘ failed: Error during WebSocket handshake: Unexpected response code: 400 &emsp;&emsp;看到这个错误信息后，确定这是服务端返回的400响应。既然可以请求到服务端，就说明客户端这边是没有问题的，那么问题最可能出在客户端和服务端之间。由于中间层使用了Nginx做转发，所以导致服务端无法知道这是一个合法的WebSocket请求。于是立刻查找了网上资料，在Nginx配置文件加入了以下配置，成功解决了这个问题。 server &#123; location / &#123; proxy_pass http://localhost:&#123;port&#125;; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; &#125;&#125; &emsp;&emsp;接着，连忙拿域名进行再次连接测试，终于看到了101 Switching Protocols的响应Status Code。就这样，也算是终于解决完在 HTTPS 下以 wss://{域名}/ 的方式连接 WebSocket的一系列问题。不过，最后这其中还有一个小问（插）题（曲）。 关于Nginx中的WebSocket配置 &emsp;&emsp; 自1.3 版本开始，Nginx就支持 WebSocket，并且可以为 WebSocket 应用程序做反向代理和负载均衡。WebSocket 和 HTTP 是两种不同的协议，但是 WebSocket 中的握手和 HTTP 中的握手兼容，它使用 HTTP 中的 Upgrade 协议头将连接从 HTTP 升级到 WebSocket，当客户端发过来一个 Connection: Upgrade请求头时，其实Nginx是不知道的。所以，当 Nginx 代理服务器拦截到一个客户端发来的 Upgrade 请求时，需要我们显式的配置Connection、Upgrade头信息，并使用 101（交换协议）返回响应，在客户端、代理服务器和后端应用服务之间建立隧道来支持 WebSocket。&emsp;&emsp; 当然，还需要注意一点，此时WebSocket 仍然受到 Nginx 缺省为60秒的 proxy_read_timeout 配置影响。这意味着，如果你有一个程序使用了 WebSocket，但又可能超过60秒不发送任何数据的话，那么需要增大超时时间（配置proxy_read_timeout），要么实现一个Ping、Pong的心跳消息以保持客户端和服务端的联系。使用Ping、Pong的解决方法有额外的好处，如：可以发现连接是否被意外关闭等。 &emsp;&emsp;关于最后的这个小问题，主要是在对Nginx配置的时候将location=/的请求都进行了proxy_pass（转发）。由于h5客户端的文件打包成静态文件后，存放在服务器的指定目录下（这里假设在/root/html/static/路径下），这也就导致这种配置的情况下Nginx无法正常代理指定目录下的客户端文件。于是再一次修改配置文件，添加location配置，最终完美解决所有问题。 location /static/ &#123; root /root/html; &#125; 4. 写在最后&emsp;&emsp;事故一波三折，现在回想起当时，也是一把辛酸史，一把辛酸泪（累）啊。所以仅以此文，记录下我的填“坑”过程。","categories":[{"name":"websocket","slug":"websocket","permalink":"https://blog.mariojd.cn/categories/websocket/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://blog.mariojd.cn/tags/websocket/"},{"name":"wss","slug":"wss","permalink":"https://blog.mariojd.cn/tags/wss/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.mariojd.cn/tags/nginx/"}]},{"title":"阿里技术精华干货整理（持续更新...）","slug":"阿里技术精华干货整理（持续更新...）","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2018/04/18/阿里技术精华干货整理（持续更新...）/","link":"","permalink":"https://blog.mariojd.cn/2018/04/18/阿里技术精华干货整理（持续更新...）/","excerpt":"","text":"&emsp;&emsp;本文用于整理阿里开源出来的技术电子书，更多精彩请搜微信公众号：“阿里技术”。 Java《阿里巴巴Java开发手册》（终极版） 官方下载 备用下载 《阿里巴巴Java开发规约》（扫描插件） GitHub仓库 使用指南 Android《阿里巴巴Android开发手册》 官方下载 备用下载 《深入探索Android热修复技术原理》 官方下载 备用下载 其它《阿里技术参考图册》（研发篇） 官方下载 备用下载 《阿里技术参考图册》（算法篇） 官方下载 备用下载 《2017阿里技术年度精选集上》 官方下载 备用下载 《2017阿里技术年度精选集下》 官方下载 备用下载 《九年双11：互联网技术超级工程》 官方下载 备用下载 《强化学习在阿里的技术演进与业务创新》 官方下载 备用下载 《不一样的技术创新——阿里巴巴2016双11背后的技术》 备用下载 欢迎大家留言补充","categories":[{"name":"学习资源","slug":"学习资源","permalink":"https://blog.mariojd.cn/categories/学习资源/"}],"tags":[{"name":"学习资源","slug":"学习资源","permalink":"https://blog.mariojd.cn/tags/学习资源/"},{"name":"阿里技术","slug":"阿里技术","permalink":"https://blog.mariojd.cn/tags/阿里技术/"}]},{"title":"使用Spring RestTemplate访问Rest服务","slug":"使用Spring RestTemplate访问Rest服务","date":"un33fin33","updated":"un22fin22","comments":true,"path":"2018/04/04/使用Spring RestTemplate访问Rest服务/","link":"","permalink":"https://blog.mariojd.cn/2018/04/04/使用Spring RestTemplate访问Rest服务/","excerpt":"","text":"RestTemplate简介 Spring’s central class for synchronous client-side HTTP access.It simplifies communication with HTTP servers, and enforces RESTful principles.It handles HTTP connections, leaving application code to provide URLs(with possible template variables) and extract results. &emsp;&emsp;上面这段是RestTemplate类中的简单介绍，RestTemplate是Spring3.0后开始提供的用于访问 Rest 服务的轻量级客户端，相较于传统的HttpURLConnection、Apache HttpClient、OkHttp等框架，RestTemplate大大简化了发起HTTP请求以及处理响应的过程。本文关注RestTemplate是如何使用的，暂不涉及内部的实现原理。 &emsp;&emsp;RestTemplate支持多种的请求方式，具体参考下表： HTTP method RestTemplate methods GET getForObject、getForEntity POST postForObject、postForEntity、postForLocation PUT put DELETE delete HEAD headForHeaders OPTIONS optionsForAllow PATCH patchForObject any exchange、execute 引入RestTemplate 方式一，使用无参构造器直接new一个对象 private RestTemplate restTemplate = new RestTemplate(); 方式二，先注册成Spring的Bean对象，之后使用的时候直接注入@Beanpublic RestTemplate restTemplate()&#123; return new RestTemplate();&#125; @Autowiredprivate RestTemplate restTemplate; 测试准备&emsp;&emsp;新建User对象，用于下面不同请求方式的测试。 @Datapublic class User &#123; /** * id */ private Long id; /** * 用户名 */ private String username; /** * 年龄 */ private Integer age; &#125; GET请求&emsp;&emsp;GET请求对应两个方法，getForObject()和getForEntity()，每个方法又对应有具体的三个重载方法。这两者的区别在于getForObject()返回的是一个简单的对象，而getForEntity()响应的数据中，还额外包含有与HTTP相关的信息，如响应码、响应头等。 /** * GET资源 (发送一个HTTP GET请求，返回的请求体将映射为一个对象) * &lt;p&gt; * 1. 执行根据URL检索资源的GET请求 * 2. 根据responseType参数匹配为一定的类型 * 3. getForObject()只返回所请求类型的对象信息 */@Testpublic void getForObject() &#123; long id = 0; //URL中的&#123;id&#125;占位符最终将会用方法的id参数来填充 String url = \"http://localhost:9000/user/&#123;id&#125;\"; //重载1：最后一个参数是大小可变的参数列表，每个参数都会按出现顺序插入到指定URL的占位符中 User user = restTemplate.getForObject(url, User.class, id); System.out.println(\"user = \" + user); //重载2：将id参数放到Map中，并以id作为key，然后将这个Map作为最后一个参数 Map&lt;String, String&gt; urlParams = new HashMap&lt;&gt;(1); urlParams.put(\"id\", String.valueOf(id)); User user2 = restTemplate.getForObject(url, User.class, urlParams); System.out.println(\"user2 = \" + user2); //重载3：构造URL对象，要在url上进行字符串拼接，不推荐使用 url = \"http://localhost:9000/user/\" + id; User user3 = restTemplate.getForObject(URI.create(url), User.class); System.out.println(\"user3 = \" + user3);&#125; /** * GET资源 (发送一个HTTP GET请求，返回的ResponseEntity包含了响应体所映射成的对象) * &lt;p&gt; * 1. 执行根据URL检索资源的GET请求 * 2. 根据responseType参数匹配为一定的类型 * 3. getForEntity()方法会返回请求的对象以及响应相关的额外信息 */ @Test public void getForEntity() &#123; long id = 1; //URL中的&#123;id&#125;占位符最终将会用方法的id参数来填充 String url = \"http://localhost:9000/user/&#123;id&#125;\"; //重载1：同getForObject()，只不过返回的类型是ResponseEntity ResponseEntity&lt;User&gt; userResponseEntity = restTemplate.getForEntity(url, User.class, id); User user = userResponseEntity.getBody(); HttpStatus statusCode = userResponseEntity.getStatusCode(); int statusCodeValue = userResponseEntity.getStatusCodeValue(); HttpHeaders headers = userResponseEntity.getHeaders(); System.out.println(\"user = \" + user + \"; statusCode = \" + statusCode + \"; statusCodeValue = \" + statusCodeValue + \"; headers = \" + headers); //重载1：同getForObject()，只不过返回的类型是ResponseEntity Map&lt;String, String&gt; urlParams = new HashMap&lt;&gt;(1); urlParams.put(\"id\", String.valueOf(id)); ResponseEntity&lt;User&gt; userResponseEntity2 = restTemplate.getForEntity(url, User.class, urlParams); System.out.println(\"userResponseEntity2 = \" + userResponseEntity2); //重载3：同getForObject()，只不过返回的类型是ResponseEntity url = \"http://localhost:9000/user/\" + id; ResponseEntity&lt;User&gt; userResponseEntity3 = restTemplate.getForEntity(URI.create(url), User.class); System.out.println(\"userResponseEntity3 = \" + userResponseEntity3); &#125; POST请求&emsp;&emsp;POST请求对应三个方法，postForObject()、postForEntity()和postForLocation()，每个方法同样对应有三个具体的重载方法。postForObject()、postForEntity()类似于getForObject()和postForEntity()，postForLocation()返回的是一个URI对象。 /** * POST资源 (POST数据到一个URL，返回根据响应体匹配形成的对象) */@Testpublic void postForObject() &#123; String url = \"http://localhost:9000/user\"; //重载1 &amp; 重载2 User user1 = new User(); user1.setAge(20); user1.setUsername(\"张三\"); //第4个参数可以是Object... uriVariables 或者 Map&lt;String, ?&gt; uriVariables User u1 = restTemplate.postForObject(url, user1, User.class); System.out.println(\"user1 = \" + u1); //重载3 User user2 = new User(); user2.setAge(30); user2.setUsername(\"李四\"); User u2 = restTemplate.postForObject(URI.create(url), user2, User.class); System.out.println(\"user2 = \" + u2);&#125; /** * POST资源 (POST数据到一个URL，返回包含一个对象的ResponseEntity，这个对象是从响应体中映射得到的) */@Testpublic void postForEntity() &#123; String url = \"http://localhost:9000/user\"; // 重载1 &amp; 重载2 User user3 = new User(); user3.setAge(25); user3.setUsername(\"王五\"); // 第4个参数可以是Object... uriVariables 或者 Map&lt;String, ?&gt; uriVariables ResponseEntity&lt;User&gt; userResponseEntity = restTemplate.postForEntity(url, user3, User.class); User userBody = userResponseEntity.getBody(); HttpStatus statusCode = userResponseEntity.getStatusCode(); int statusCodeValue = userResponseEntity.getStatusCodeValue(); HttpHeaders headers = userResponseEntity.getHeaders(); System.out.println(\"user = \" + userBody + \"; statusCode = \" + statusCode + \"; statusCodeValue = \" + statusCodeValue + \"; headers = \" + headers); // 重载3 User user4 = new User(); user4.setAge(35); user4.setUsername(\"陆六\"); ResponseEntity&lt;User&gt; userResponseEntity2 = restTemplate.postForEntity(URI.create(url), user4, User.class); System.out.println(\"userResponseEntity2 = \" + userResponseEntity2);&#125; /** * POST资源 (POST数据到一个URL) * 如果服务端在响应的Location头信息中返回新资源的URL，接下来postForLocation()会以String的格式返回该URL */@Testpublic void postForLocation() &#123; String url = \"http://localhost:9000/user\"; User user = new User(); user.setAge(28); user.setUsername(\"七七\"); // 重载1 &amp; 重载2 // 第3个参数可以是Object... uriVariables 或者 Map&lt;String, ?&gt; uriVariables URI uri = restTemplate.postForLocation(url, user); if (Objects.nonNull(uri)) &#123; String location = uri.toString(); System.out.println(\"location = \" + location); &#125; // 重载3 URI uri1 = restTemplate.postForLocation(URI.create(url), user); if (Objects.nonNull(uri1)) &#123; String location = uri1.toString(); System.out.println(\"location = \" + location); &#125;&#125; PUT请求&emsp;&emsp;PUT请求只有一个方法：put()，对应三个具体的重载方法，put请求返回值为void。 /** * PUT资源 (PUT资源到特定的URL) */@Testpublic void put() &#123; long id = 1; //URL中的&#123;id&#125;占位符最终将会用方法的id参数来填充 String url = \"http://localhost:9000/user/&#123;id&#125;\"; User user = new User(); user.setId(id); user.setUsername(\"update 张三\"); user.setAge(99); //重载1 restTemplate.put(url, user, id); //重载2 Map&lt;String, String&gt; urlParams = new HashMap&lt;&gt;(1); urlParams.put(\"id\", String.valueOf(id)); restTemplate.put(url, user, urlParams); //重载3 restTemplate.put(URI.create(\"http://localhost:9000/user/\" + id), user);&#125; DELETE请求&emsp;&emsp;DELETE请求同样只有一个方法：delete()，对应有三个具体的重载方法，delete请求返回值为void。 /** * DELETE资源 (在特定的URL上对资源执行HTTP DELETE操作) */@Testpublic void delete() &#123; long id = 1; //URL中的&#123;id&#125;占位符最终将会用方法的id参数来填充 String url = \"http://localhost:9000/user/&#123;id&#125;\"; //重载1 restTemplate.delete(url, id); //重载2 Map&lt;String, String&gt; urlParams = new HashMap&lt;&gt;(1); urlParams.put(\"id\", String.valueOf(id)); restTemplate.delete(url, urlParams); //重载3 restTemplate.delete(URI.create(\"http://localhost:9000/user/\" + id));&#125; HEAD &amp; OPTIONS &amp; PATCH 请求&emsp;&emsp;这几种请求方式比较少见和少用，这里就不再说明了。 any（通用）请求&emsp;&emsp;通用的请求主要是指execute()和exchange()方法，这两个方法又分别对应有三个和八个具体的重载方法。 /** * 交换资源 (在URL上执行特定的HTTP方法，返回包含对象的ResponseEntity，这个对象是从响应体中映射得到的) * 允许在发送给服务端的请求中设置头信息 * 支持GET、POST、PUT、DELETE... */@Testpublic void exchange() &#123; long id = 1; String url = \"http://localhost:9000/user/&#123;id&#125;\"; //GET资源 //参数3是请求头部分；参数4是响应数据要转成对象；最后一个参数用于替换URL中的占位符 ResponseEntity&lt;User&gt; userResponseEntity = restTemplate.exchange(url, HttpMethod.GET, null, User.class, id); System.out.println(\"exchange = \" + userResponseEntity + \"; response body = \" + userResponseEntity.getBody()); //POST资源 String url2 = \"http://localhost:9000/user\"; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String jsonParams = \"&#123;\\\"username\\\":\\\"123\\\",\\\"age\\\":23&#125;\"; HttpEntity&lt;User&gt; httpEntity = new HttpEntity(jsonParams, headers); ResponseEntity&lt;User&gt; responseEntity = restTemplate.exchange(url2, HttpMethod.POST, httpEntity, User.class); System.out.println(\"exchange = \" + responseEntity + \"; response body = \" + responseEntity.getBody()); //PUT and DELETE忽请自行测试&#125; &emsp;&emsp;execute()的操作相对而言会比较麻烦，建议大家多使用exchange()，这里就不再贴代码进行说明了。 补充说明&emsp;&emsp;以上测试代码可以在我的GitHub仓库中找到。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/tags/Java/"},{"name":"RestTemplate","slug":"RestTemplate","permalink":"https://blog.mariojd.cn/tags/RestTemplate/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.mariojd.cn/tags/Spring/"}]},{"title":"程序员神器，IntelliJ IDEA 2018.1 正式发布","slug":"程序员神器，IntelliJ IDEA 2018.1 正式发布","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2018/04/03/程序员神器，IntelliJ IDEA 2018.1 正式发布/","link":"","permalink":"https://blog.mariojd.cn/2018/04/03/程序员神器，IntelliJ IDEA 2018.1 正式发布/","excerpt":"","text":"工欲善其事必先利其器，如果有一款IDE可以让你更高效地专注于开发以及源码阅读，为什么不试一试? 3月27日，jetbrains正式发布期待已久的IntelliJ IDEA 2018.1，再次让人眼前一亮：什么，还能这么玩？ 下面，我们来快速了解一下 IDEA 2018.1 最新版本给我们带来哪些惊喜 1. stream代码自动生成更智能 IDEA对java代码的自动化生成令人惊叹，一个alt + enter或者alt + /可以省去很多敲打键盘的操作。本次更新对stream api的支持更加智能化，如上图，如果对一个list filer掉指定的type之后，在后续的map操作中，自动给你加上一个cast。 2. while循环优化 IDEA智能检测代码逻辑，将原本丑陋的代码自动改写，while优化也是继承自此理念。上图中展示的是，while if break 逻辑，直接修改成do while，代码颜值和易理解程度明显提升。 3. 优化多余的资源关闭操作 使用过IDEA的同学可能会经常看到代码里面有灰色的代码，这就提示你，这段代码是多余了，不可达的代码，可以删掉，代码更干净整洁。上图中展示的是，当你已经使用了try resource的方式来自动关闭资源，没有必要再手动调用一次close，显示成灰色，alt+enter一键自动删除。 4. 字符串数组自动排序 这个功能也是非常贴心，不得不佩服jetbrain对产品细节的打磨。如果你代码里面有一堆字符串常量，想做一个简单的按字母排序，只需要在数组上按下alter+enter，然后sort conetnt，IDEA会自动排序，秒级完成。 5. 拷贝构造函数完整性提示 拷贝构造函数在实际项目开发过程中也是比较常见的，通过同一个类的对象，生成另外一个对象，这个过程中，如果少set了一个属性，在后续的逻辑中很容易出现NPE。上图展示的是，当你实现拷贝构造函数的时候，忘了拷贝 myFileFilter和 myForcedToUseIdeaFileChooser这两个属性，IDEA会给你智能提示，让你修改。 6. postfix支持自定义模板postfix可以说是IDEA里面最有特色的一大功能，和live template并驾齐驱，完成一些非常快速的操作，关于这两个强大的功能可以翻到文末我之前录制的视频课程，这里不过多介绍。在这之前，我一直觉得postfix比不上live template，是因为他不支持自定义模板，一直想不通为什么jetbrain不开发这个功能来提高postfix的地位，没想到2018.1终于实现了自定义模板。 上图中，自定义了 .do这个postfix，我们在敲了一个表达式之后，唤出 do这个postfix，IDEA自动送你一个do while循环，并且随后光标自动跳转到你接下来需要书写逻辑的地方，棒不棒？ 7. 自定义类生成文件名前后缀 这个功能是IDEA对自动生成类文件的增强，IDEA的自动生成类文件，举两个简单的例子 你创建好一个接口之后，直接在接口名处按下alt+enter，动一动上下键，一路按回车，可以给你自动生成这个接口的实现，默认后缀为Impl 你要对当前类写个UT，直接在当前类下按下cmd+shift+t，一路按回车，动一动上下键，空格键，可以给你自动生成这个类的UT，默认后缀为Test 之前这个默认值在IDEA中是不能修改的，新版本不仅可以修改这个默认后缀，甚至连默认前缀也可以修改，自由度更高，可以让自动生成的类更加贴合你的代码风格 8. debug异常模拟 IDEA的debug功能可以说让我爱不释手，无论是bug的排查，源码的阅读，超多惊艳的功能几乎每次都能让你瞬间定位关键代码。在之前的版本，IDEA已经实现了表达式（段落）求值，动态值修改，force return等强悍的调试功能，新版增加了Exception模拟功能。debug的时候，你可以在任意一个地方，模拟异常的抛出，这在验证代码的异常完备性方面非常有用。 9. 断点栈轨迹在阅读netty源码的过程中，我最喜欢的功能就是使用IDEA的调用栈迅速了解某段代码执行的上下文环境，调用栈被挂起之后，只需要动一动上下方向键，就可以快速熟悉这段代码的执行路径。 新版本中，如上图，IDEA对breakpoint的功能得到进一步的增强，让你的断掉调试在控制台留下轨迹，每经过一个断点，都会在控制台打印出这个断点的调用栈，下次，可以不用调试你就能知道断点处的代码原始的调用链是什么。 10. 更强大的全局文本替换 IDEA对文本的处理可以说是相当强悍了，无论搜索还是替换，可以自定义范围，文件名，甚至支持预览效果。新版本对全局文本替换功能进行进一步的扩充，上图展示的是，你想把所有 xxController文件替换成 xxProducer，直接上两段正则表达式就可以迅速完成，并且在窗口下方实时预览修改后的效果。 11. SpringBoot整合进一步优化IDEA和Spring的整合可以说是天衣无缝，Spring IOC和AOP的特性在IDEA中得到了充分的可视化体现，无比强大的关联功能让人叹为观止，详细可以翻到文末我录制的视频。 新版本更是对SpringBoot的整合达到了一种登峰造极的程度。上面图展示的是，当你的SpringBoot应用启动之后，在所有对外提供API的方法，你都可以直接点个鼠标就可以发起HTTP调用，发起HTTP调用有两种方式： 一种方式是直接发起调用，不用手动输入url，调用之后结果直接展示在控制台 另外一种调用方式更为强大，IDEA给你自动给你生成一个.http文件，这个文件里面，你可以自定义http请求的参数，url，并且每一次调用的结果都保存为一个文本文件，甚至可以进行调用结果的对比。 12. git部分提交与changelistIDEA对git的可视化支持以及各种快速便捷的操作在代码冲突解除、开源代码历史版本追溯、code review发挥了强大的作用，你根本不需要第二个可视化版本控制工具。在IDEA的版本控制管理的概念里有一个changelist的术语，指的是，你可以把每一处更改扔到不同的变更集合里，提交代码的时候，你可以选择不同的变更集合进行提交，剩下的变更集合，变更还在，但是不会提交到仓库中。这个应用场景是，比如，你遇到一个新项目，想快速了解这个项目，你可以随意做修改，把这些修改扔到一个自定义的changelist中，而在真正完成task的时候（一般刚开始接触新项目，实现的需求都比较简单，几行代码搞定），把需求实现的变更集进行提交即可，之前的实验代码可以留在你的项目中，你可以进一步地做实验。 本次版本的更新，细粒度版本控制得到了进一步的增强，上面这幅图展示的是，你在提交代码的时候，窗口右半侧左边栏，每一处改动都会有一个单选框，如果你在code review的时候，不想提交某一处改动，只需要把前面的单选框取消勾选即可，这样，结果就是，代码还在本地项目中，但是不会提交到版本库。 此外，你还可以把你不想提交的代码扔到一个自定义changelist里，代码还在，但是不会提交，如上图。 13. git历史记录增强在阅读netty源码的过程中，有的时候我会发现注释和代码逻辑牛头不对马嘴，于是，我使用了IDEA的git历史记录功能之后发现，原来这段注释是应用在很久之前的代码上的，老代码注释一直未删除，这也说明了你在阅读开源项目的时候，不要盲目相信权威，要多思考，要相信自己的判断。 本次git的历史记录的增强，指的是，你在阅读某个版本的代码，想了解这个版本中的某一个文件的提交历史，你可以直接在这个文件上右键，然后查看针对当前版本，查看这个文件的提交历史，所有的改动一览无余。 14. 弹出式javadoc 对的，新版本IDEA终于支持弹出式java doc了，当你鼠标放到某个方法，参数，类型上去的时候，自动给你弹出对应的文档的解释，并且给出文档表现形式是经过美化的。 15. Kubernetes支持 IDEA之所以如此优秀，是因为jetbrain一直会关注行业的最新动态，迅速实现对java生态圈中热门技术的整合。我记得当年Docker刚火起来的时候，IDEA就已经开始对Docker的整合了，并且在每个版本里面迅速迭代，目前IDEA对docker的支持已经做得非常出色了。 上图展示的是IDEA对Kubernetes的支持，只敲了几个字母，一个Kubernetes资源文件模板就生成了，然后，一个批量编辑，光标自动定位，一个完整的资源文件就已经写完了，IDEA在2018.1版本中对Kubernetes的支持做了非常多的增强，感兴趣的同学可以看下官网博客的专题介绍。 结束语以上就是我对本次 IntelliJ IDEA 2018.1 版本更新的解读，如果你非常迫切想提升开发效率，提升代码质量，可以跳转到我的IDEA系列课程，免费，看完这个课程之后再来读这篇文章，可能会更容易理解。 原文出处：IntelliJ IDEA 2018.1正式发布微信公众号：netty技术内幕注：以上内容有做部分修改","categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/categories/IDEA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/tags/Java/"},{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"}]},{"title":"在完成了10000步21天钉钉运动大神赛之后...","slug":"在完成了10000步21天钉钉运动大神赛之后","date":"un00fin00","updated":"un55fin55","comments":true,"path":"2018/04/01/在完成了10000步21天钉钉运动大神赛之后/","link":"","permalink":"https://blog.mariojd.cn/2018/04/01/在完成了10000步21天钉钉运动大神赛之后/","excerpt":"","text":"&emsp;&emsp;3月5日，钉钉宣布启动 “ 酷公司运动季 ”，拿出88万元奖金鼓励上班族减肥，运动达标者不但可以成功减掉赘肉，还能一起来瓜分奖金。开启挑战可以选择7天、14天、21天赛程，只要在赛程内按照要求每天的钉钉运动步数达到10000步，即可获得奖励资格。支付2元运动契约金，即可加入“多走半小时，日行一万步“活动。&emsp;&emsp;活动时间：2018年3月5日一4月21日(3月31日23:59:59为最晚参与时间) &emsp;&emsp;目前所在的企业，从入职开始到现在，内部沟通协作的主要软件也就是钉钉。三月初的时候，偶然在钉钉运动一栏中发现了这个活动，当时也没怎么犹豫，果断支付了2元契约金，选的也是最长的21天挑战。没想到，坎坎坷坷这一路下来，发现这个挑战的难度还是蛮大的，不过好在几天前，终于让我拿下了这个21天大神挑战赛。 &emsp;&emsp;大概从大二开始的时候，就慢慢在养成跑步的习惯，不过一直都选择在晚上进行，因为如果是其它时间段的话，像早上或者是中午这种时间，南方的太阳这么火辣，一出汗就得换衣服、洗衣服，也是嫌麻烦事多。之前在学校夜跑的话，一般会选择晚课之后这个时间点，每次运动的量也不多，围着操场跑一二公里的样子也就够了，但好在基本每天都有坚持下来，总体大学这四年下来，也算是没丢了身体这个本钱，是蛮幸运的。 &emsp;&emsp;后来，也就是去年暑假，出来另外一个城市开始实习了。刚开始那会，也没怎么把线程切换过来，附近一时半会也没找到比较好的运动场所，所以就懈怠了没有去跑步。我更倾向于在环境好一点的地方来运动，像公园、大学这种一般环境都不错，很可惜这附近真的没有，没办法，也不太喜欢健身房这种商业化又比较压抑的场所。 &emsp;&emsp;大概实习一个月之后，发现身体实在吃不消了，果断上了某宝，买了一双运动鞋，铁了心要把身体弄好。到现在，这半年多的时间里，经历过和同事一起约跑的夜晚，也经历过一个人去远一点的学校、公园跑步的周末。 &emsp;&emsp;也许天生就比较喜欢运动。大学这四年里，每年的体测都能拿个80分+，知足。加上后来，选择了做一名程序员，如果不坚持运动的话，我不知道未来会怎样，是先秃顶呢？还是挺着个啤酒肚？而且这个职业，吐槽的新闻可不少，像去麦当劳约会的，背双肩、穿拖鞋上班的，还有看秃顶猜年龄能力的，总之是不会太轻松的啦。 &emsp;&emsp;身处于高压的行业，最大的感受除了经常被产品那群人当“猴”耍之外，还有永远不确定的需求、改不完的Bug以及写不完的代码。列一下程序员最容易得的职业病。 键盘手 鼠标手 颈椎病 腰椎病 眼疲劳、用眼过度 久坐对前列腺的危害以及肥胖问题 饮食、作息不规律导致的胃病等一系列问题 &emsp;&emsp;该庆幸自己还年轻，可以及早的做好预防措施。如果你也喜欢某一运动，那就把它当成一辈子的事业去坚持吧！我一直都坚信，身体好才是最重要的正事。看到过这么一句话，如果暂时做不到拼得比别人狠，那就比谁拼得久吧。 &emsp;&emsp;没错，钉钉这次举办的21天大神赛不是开始，也不会是结束。喜欢运动的那种感觉，很轻松、释放、无所顾忌。一辈子很长，很多事要用行动去践行，共勉！ &emsp;&emsp; 4月21日，钉钉21天大神赛正式落下帷幕。最后Show一下战绩。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://blog.mariojd.cn/categories/随笔/"}],"tags":[{"name":"跑步","slug":"跑步","permalink":"https://blog.mariojd.cn/tags/跑步/"},{"name":"钉钉运动","slug":"钉钉运动","permalink":"https://blog.mariojd.cn/tags/钉钉运动/"}]},{"title":"实现Java热部署的几种解决方案","slug":"实现Java热部署的几种解决方案","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/03/30/实现Java热部署的几种解决方案/","link":"","permalink":"https://blog.mariojd.cn/2018/03/30/实现Java热部署的几种解决方案/","excerpt":"","text":"百度百科：热部署，就是应用正在运行的时候就可以升级软件，而不需要重新启动应用。 spring-loaded 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;version&gt;1.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; ps：据说此方法还需要手动编译（Ctrl + Shift + F9），请亲测！ spring-boot-devtools 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;!-- 表示依赖不会传递，之后依赖该module的项目如需继续使用，则需要再次引入 --&gt;&lt;/dependency&gt; JRebel 安装插件 激活JRebel 启动运行 若不起效 全局配置 对比 方式 效果 spring-loaded 需手动编译 spring-boot-devtools 会重新加载整个应用 JRebel 只加载修改类（当有错误时不会）。无需手动编译，不会重新加载整个应用 参考文章 SpringBoot初始教程之热部署(五)JRebel无限制版IntelliJ IDEA 热部署插件 JRebel 安装激活及使用intellij idea 热部署 jrebel 详细配置","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/categories/Java/"},{"name":"热部署","slug":"Java/热部署","permalink":"https://blog.mariojd.cn/categories/Java/热部署/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/tags/Java/"},{"name":"热部署","slug":"热部署","permalink":"https://blog.mariojd.cn/tags/热部署/"}]},{"title":"Fiddler实现微信授权开发调试","slug":"Fiddler实现微信授权开发调试","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2018/03/30/Fiddler实现微信授权开发调试/","link":"","permalink":"https://blog.mariojd.cn/2018/03/30/Fiddler实现微信授权开发调试/","excerpt":"","text":"一、下载、安装Fiddler二、微信授权调试&emsp;&emsp; 案发现场： 某天，一名正儿八经的开发”猿”，在疯狂一顿Coding之后，他完成了微信授权登录功能的编码。下来他想先在本地调试一下，然后再部署到线上环境。于是在本地Run起了Project，假设微信回调的地址是：localhost:9002。这时，他就可以利用Fiddler进行代理测试，具体操作实现请参考以下两种方法。 &emsp;&emsp; PS： 请先自行登录微信公众平台进行相关配置。 1. Fiddler + 微信web开发者工具 打开微信web开发者工具，选择公众号网页开发： 修改Fiddler中的Hosts配置信息 &emsp;&emsp; 完成以上配置，即可利用微信web开发者工具在PC本地进行微信授权调试，就这么简单。 2. Fiddler + 手机（需结合方法1的配置操作） 确保手机、电脑在同一个局域网，查看PC的ip地址 Fiddler代理配置 手机代理信息配置 &emsp;&emsp; 完成以上配置，即可使用手机进行微信授权（可自行构造请求微信授权），微信回调后会走PC运行的项目接口，大概就这么简单。 三、推荐两个小工具 内网映射工具（第三种调试方法，具体请参考在线教程）：NATAPP Hosts修改软件：SwitchHosts","categories":[{"name":"抓包工具","slug":"抓包工具","permalink":"https://blog.mariojd.cn/categories/抓包工具/"}],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"https://blog.mariojd.cn/tags/Fiddler/"},{"name":"微信授权","slug":"微信授权","permalink":"https://blog.mariojd.cn/tags/微信授权/"},{"name":"代理调试","slug":"代理调试","permalink":"https://blog.mariojd.cn/tags/代理调试/"}]},{"title":"IDEA快捷键拆解系列（后记）","slug":"IDEA快捷键拆解系列（后记）","date":"un33fin33","updated":"un55fin55","comments":true,"path":"2018/03/28/IDEA快捷键拆解系列（后记）/","link":"","permalink":"https://blog.mariojd.cn/2018/03/28/IDEA快捷键拆解系列（后记）/","excerpt":"","text":"&emsp;&emsp;没错，这是IDEA快捷键拆解系列的最后一篇文章了，也是对应本系列前言的一篇。 &emsp;&emsp;对于绝大多数开发者而言，把一款编辑器用熟了之后，再突然切换到其它款的编辑器的话，这个适应阶段一般都比较艰辛和漫长。但博主有理由相信，大神级别的程序员总是会先去熟悉快捷键，然后其它应用的快捷键冲突能改的都改掉，而不是把快捷键都修改成原来的。个人也很推荐这么做，总结了以下几种原因。 团队协作开发的统一； 官方定义的快捷键代表着本编辑器的最佳实践操作； 方便与其它同系列的子产品快捷键做统一。 &emsp;&emsp;使用JetBrains的产品有一个很大的好处，这在前言那篇文章里面也提到过，这家公司拥有很多种主流开发语言的编辑器产品。所以一般只要学好了IDEA的快捷键，那么在跨语言学习和开发使用新的编辑器的时候，我们都可以非常轻松、快速的迁移和上手快捷键操作。其实这里IDEA还有一个更为人性化的地方，就是针对从Eclipse、NetBeans或者是从Emacs中迁移过来的开发者，都提供了一整套的原生编辑器快捷键，我们也只需要做一下小小的配置即可（如下图所示），不过还是再一次建议使用IDEA默认的快捷键来做开发。 &emsp;&emsp;在这里，介绍一下IDEA强大的Local History功能，这对于经常接触和使用VCS（版本控制系统）的开发者来说是比较好理解的。对于Local History，从字面上的意思来理解，就是IDEA为开发者提供了一个本地的VCS，然后针对我们项目上的任何操作，在本地都做了一个历史的记录。具体查看和操作可以通过右键点击，或者是快捷键Alt + 反引号，然后找到Local History即可。 &emsp;&emsp;如上图所示，除了Show History之外，我们还可以配合着进行Put Label的操作，这也是Local History中一个非常棒的辅助功能。 &emsp;&emsp;针对IDEA中，博主目前还发现了几个强大的功能，如SSH Session和Test Restful Web Service，这两个可以在顶部的工具栏“Tools”中展开找到。 SSH Session：类似于XShell、SecureCRT和Putty这样的服务器客户端连接工具，好像暂时不能存储连接的会话信息Test Restful Web Service：类似于Postman的测试工具，功能方面可能还有待完善 &emsp;&emsp;还有一个就是Database功能，这个可以在顶部的工具栏“View”，然后是“Tool Windows”中展开找到。 &emsp;&emsp;当然了，IDEA中还有一些其它的功能也很强大，这可能在整一个的拆解系列中没有细说到，又或者是还没留意到，如果后续有需要补充和完善的，博主会及时的更新到这里，也非常欢迎各位的留言。孰能生巧，快捷键用多了自然而然就熟了，但前提是得知道有这么一个的快捷键，包括博主本人目前也还在一直的学习当中。好啦，持续了断断续续一整个月的时间，本系列到此就先暂告一段落了。最后，与大家一起加油、共勉！ IDEA快捷键拆解系列（前言）IDEA快捷键拆解系列（一）IDEA快捷键拆解系列（二）：File篇IDEA快捷键拆解系列（三）：Edit篇IDEA快捷键拆解系列（四）：View篇IDEA快捷键拆解系列（五）：Navigate篇IDEA快捷键拆解系列（六）：Code篇IDEA快捷键拆解系列（七）：Analyze篇IDEA快捷键拆解系列（八）：Refactor篇IDEA快捷键拆解系列（九）：Build篇IDEA快捷键拆解系列（十）：Run篇IDEA快捷键拆解系列（十一）：Tools篇IDEA快捷键拆解系列（十二）：VCS篇IDEA快捷键拆解系列（十三）：Window篇IDEA快捷键拆解系列（十四）：Help篇IDEA快捷键拆解系列（十五）：经验篇IDEA快捷键拆解系列（十六）：插件篇IDEA快捷键拆解系列（十七）：Debug篇IDEA快捷键拆解系列（十八）：Live Templates篇IDEA快捷键拆解系列（十九）：Postfix篇IDEA快捷键拆解系列（后记）","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"个人感悟","slug":"编辑器/个人感悟","permalink":"https://blog.mariojd.cn/categories/编辑器/个人感悟/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"Eclipse","slug":"Eclipse","permalink":"https://blog.mariojd.cn/tags/Eclipse/"},{"name":"个人感悟","slug":"个人感悟","permalink":"https://blog.mariojd.cn/tags/个人感悟/"}]},{"title":"解决IDEA无法提示导入java.util.Date的问题","slug":"解决IDEA无法提示导入java.util.Date的问题","date":"un22fin22","updated":"un55fin55","comments":true,"path":"2018/03/27/解决IDEA无法提示导入java.util.Date的问题/","link":"","permalink":"https://blog.mariojd.cn/2018/03/27/解决IDEA无法提示导入java.util.Date的问题/","excerpt":"","text":"&emsp;&emsp;之前有一段时间在使用IDEA的时候，发现通过快捷键Alt + Enter导入并没有提示有java.util.Date的包，仅仅只有java.sql.Date的包。于是每次使用都需要通过手写import java.util.Date;来进行导包。博主在好生不爽了一段时间后，终于在网上找到了解决办法，本文就是用来记录一下解决过程的。 &emsp;&emsp;找到设置（Alt + Shift + S），搜索“Auto Import”。如下图所示，只需要把java.util.Date导入提示的排除设置删除即可。 &emsp;&emsp;同理，因为一般项目中很少使用得到java.sql.Date，所以我们可以添加这么一条设置，用于排除java.sql.Date的导入提示。","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十九）：Postfix篇","slug":"IDEA快捷键拆解系列（十九）：Postfix篇","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2018/03/26/IDEA快捷键拆解系列（十九）：Postfix篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/26/IDEA快捷键拆解系列（十九）：Postfix篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十九篇。 &emsp;&emsp;本文将介绍一下IDEA另外一个强大的功能：Postfix。 &emsp;&emsp;Postfix和Live Template有点类似，但目前来看是不支持自定义的，在设置面板（快捷键：Ctrl + Alt + S）搜索“Postfix”即可。 &emsp;&emsp;从上图可以看到，目前官方定义了Java、JavaScript和Kotlin三种编程语言的Postfix。其中，Description区域描述了该Postfix的作用，Before区域是我们编码前，默认使用Tab键后，即可转换成After区域的代码效果。以下是Java中常用的一些Postfix。 ! assert cast else filed for fori format forr if inst instanceof iter lambda nn not notnull null opt return sout stream switch synchronized throw try twr while &emsp;&emsp;从定义来看，Java中的Postfix也就大概三十个，相信熟练掌握之后可以大大提高我们的编码效率。","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十八）：Live Templates篇","slug":"IDEA快捷键拆解系列（十八）：Live Templates篇","date":"un00fin00","updated":"un66fin66","comments":true,"path":"2018/03/25/IDEA快捷键拆解系列（十八）：Live Templates篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/25/IDEA快捷键拆解系列（十八）：Live Templates篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十八篇。 &emsp;&emsp;本文将介绍一下IDEA强大的Live Template功能。 &emsp;&emsp;首先，我们要知道Live Template是在哪里定义的，先按Ctrl + Shift + S进入设置，接着在输入框输入“Live Template”就可以定位到了，如下图所示。 &emsp;&emsp;从上图可以看到，IDEA官方已经帮我们定义好了一些常用的Live Template，而且针对不同的文件类型也划分了不同的Live Template Group。查看Live Template的快捷键是Ctrl + J，这里列几个比较常用的。 iterate (迭代) itar：Iterate elements of array，操作顺序迭代数组 //1.定义一个数组String[] strings = new String[];//2.输入itar后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键快速进行光标切换for (int i = 0; i &lt; strings.length; i++) &#123; String string = strings[i];&#125; ritar：Iterate elements of array in reverse order，反转迭代数组 String[] strings = new String[];//输入ritar后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换for (int i = strings.length - 1; i &gt;= 0; i--) &#123; String string = strings[i];&#125; iter：Iterate (for each..in)，ForEach迭代 List&lt;String&gt; stringList = new ArrayList&lt;&gt;();//输入iter后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换for (String s : stringList) &#123;&#125; fori：Create iteration loop，含下标的普通迭代 //输入fori后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换for (int i = 0; i &lt; ; i++) &#123;&#125; itli：Iterate elements of java.util.List，List迭代List&lt;String&gt; stringList = new ArrayList&lt;&gt;();//输入itli后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换for (int i = 0; i &lt; stringList.size(); i++) &#123; String s = stringList.get(i);&#125; itco：Iterate elements of java.util.Collection，iterator迭代 List&lt;String&gt; stringList = new ArrayList&lt;&gt;();//输入itco后会有提示，按`Enter`确认后会自动输出以下内容，默认是按`Tab`键进行光标快速切换for (Iterator&lt;String&gt; iterator = stringList.iterator(); iterator.hasNext(); ) &#123; String next = iterator.next();&#125; iten：Iterate java.util.Enumeration itit：Iterate java.util.Iterator ittok：Iterate tokens from String itve：Iterate elements of java.util.Vector define (定义) St String thrthrow new psf public static final prsf private static final psfi public static final int psfs public static final String psfs public static final String geti：Inserts singleton method getInstance public static $CLASS_NAME$ getInstance() &#123; return ;&#125; ifn：Inserts if null statement if ($VAR$ == null) &#123;&#125; inn：Inserts if not null statement if ($VAR$ != null) &#123;&#125; inst：Checks object type with instanceof and down-casts it if ($EXPR$ instanceof $TYPE$) &#123; $TYPE$ $VAR1$ = ($TYPE$)$EXPR$; $END$&#125; lazy：Performs lazy initialization if ($VAR$ == null) &#123; $VAR$ = new $TYPE$();&#125; lst：Fetches last element of an array mn：Sets lesser value to a variable mx：Sets greater value to a variable toar：Stores elements of java.util.Collection into array main psvm public static void main(String[] args) &#123;&#125; print (打印) sout：Prints a string to System.out System.out.println(); souf：Prints a formatted string to System.out System.out.printf(\"\"); serr：Prints a string to System.err System.err.println(\"\"); soutm：Prints current class and method names to System.out System.out.println(\"className.methodName\"); soutv：Prints a value to System.out System.out.println(\"variable name = \" + variable value); soutp：Prints method parameter names and values to System.out System.out.println(\"parameter name = [\" + parameter value + \"]\"); Maven dep：dependency &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt;&lt;/dependency&gt; pl：plugin &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt;&lt;/plugin&gt; repo：repository &lt;repository&gt; &lt;id&gt;&lt;/id&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;&lt;/url&gt;&lt;/repository&gt; SQL col：new column definition $col$ $type$ $null$$END$ ins：insert rows into a table insert into $table$ ($columns$) values ($END$); sel：select all rows from a table select * from $table$$END$; selc：select the number of specific rows in a table select count(*) from $table$ $alias$ where $alias$.$END$; selw：select specific rows from a table select * from $table$ $alias$ where $alias$.$END$; tab：new table definition create table $table$ ( $col$ $type$ $null$$END$); upd：update values in a table update $table_name$ set $col$ = $value$ where $END$; &emsp;&emsp;当然了，Live Templat强大的地方不仅在于官方定义好的这部分，更重要是还支持自定义的Live Template。在学习工作中，我们可以尝试把一些重复的代码抽出来变成模板，接下来我们就来看看如何自定义Live Template。 配置自定义Live Template 修改作用范围 K 新建POJO，输入自定义的Live Template快捷键，如这里是cps，按Enter键选择后光标将停留在VAR1的位置，默认按Tab键即可快速切换到VAR2的位置。 由于个人疏忽，所以截图部分Live Template存在部分错误，下面是更正后的Live Template。/** * $VAR1$ */private String $VAR2$;$END$","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十七）：Debug篇","slug":"IDEA快捷键拆解系列（十七）：Debug篇","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2018/03/24/IDEA快捷键拆解系列（十七）：Debug篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/24/IDEA快捷键拆解系列（十七）：Debug篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十七篇。 &emsp;&emsp;本文主要讲解如何利用好IDEA强大的断点调试功能，含快捷键、经验分享等。 Shortcuts：快捷键 快捷键 描述 Ctrl + F8 添加/取消断点，或直接在左侧点击添加 Ctrl + Shift + F8 查看所有断点，为断点添加条件等 F8 执行下一步 Shift + Alt + F8 强制执行下一步 F9 跳到下一个断点，如果没有则直接运行结束 Alt + F9 运行到光标所在处 Ctrl + Alt + F9 强制运行到光标处 F7 进入代码内部 Shift + F8 退出代码内部 Alt + F10 跳转到断点执行处 Alt + F8 表达式求值 Mute Breakpoints：禁用断点 Condition Breakpoints：条件断点 若光标在断点处，则快捷键为Ctrl + Shift + F8 若光标不在断点处，可通过查看所有断点来添加条件，快捷键同上Ctrl + Shift + F8 通过右键点击断点来添加条件 Evaluate Expression：表达式求值，快捷键Alt + F8 setValue：一般用于动态修改Debug中运行的值 &emsp;&emsp;在分析源码的时候，良好的Debug能力可以帮助我们快速的读懂别人的代码。IDEA为开发者们提供了全面的Debug支持，相信熟练掌握后可以大大的提高我们的Debug能力。","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十六）：插件篇","slug":"IDEA快捷键拆解系列（十六）：插件篇","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/03/23/IDEA快捷键拆解系列（十六）：插件篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/23/IDEA快捷键拆解系列（十六）：插件篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十六篇。 &emsp;&emsp;本文整理了博主用过的一些IDEA插件。其中，五星是强烈推荐，四星是比较推荐，三星仅供参考，两星的就不多说了，一星是炫酷型的插件，一般帮助也不大。最后，欢迎留言补充。 插件 描述 推荐指数 Jrebel for Intellij 热部署插件，用Jrebel做热部署，效果比使用Spring-loaded和Spring-boot-devtools好多了 ☆☆☆☆☆ CodeGlance 在代码区右边显示代码小地图，方便快速定位代码 ☆☆☆☆☆ Translation 翻译插件，目前支持谷歌和有道。切换翻译源的快捷键是：Ctrl + Shift + S，翻译选中内容的快捷键是：Ctrl + Shift + Y，弹出翻译框的快捷键是：Ctrl + Shift + O ☆☆☆☆☆ Lombok plugin 使用了Lombok需要此插件，否则可能会让人抓狂 ☆☆☆☆☆ Alibaba Java Coding Guidelines 阿里巴巴Java团队开发的一款代码规范检查插件 ☆☆☆☆☆ Properties to YAML Converter 用于将properties类型的文件转换成yaml类型 ☆☆☆☆☆ Markdown Navigator Markdown编辑插件 ☆☆☆☆ Protobuf Support protobuf文件支持插件 ☆☆☆☆ stackoverflow 右键选择并跳转Stack Overflow的插件 ☆☆☆☆ snakeYAML plugin YAML文件支持检查插件 ☆☆☆☆ FindBugs-IDEA 潜在Bug检查 ☆☆☆☆ MetricsReloaded 代码复杂度检查 ☆☆☆☆ statistic 代码统计插件 ☆☆☆☆ CheckStyle-IDEA 代码规范检查插件 ☆☆☆☆ AceJump 用于查找代码并快速定位跳转。快捷键：Ctrl + ;；然后出现蓝色区域可输入要查找的关键字；黄色部分就是对应进行跳转快捷键，挨着的绿色部分是查找的结果 ☆☆☆☆ emacsIDEAs 类似于AceJump插件 ☆☆☆☆ IdeaVim 支持在IDEA中使用Vim的插件 ☆☆☆☆ Key Promoter 快捷键显示插件，适合新手 ☆☆☆☆ ANSI Highlighter 高亮插件 ☆☆☆ Identifier Highlighter 高亮插件 ☆☆☆ GsonFormat 把Json转换成实体类 ☆☆☆ IdeaJad 反编译插件 ☆☆☆ Maven helper Maven帮助插件 ☆☆ CamelCase Switch easily between CamelCase, camelCase, snake_case and SNAKE_CASE. 快捷键：SHIFT + ALT + U ☆☆ Eclipse Code Formatter Eclipse 代码风格格式化插件 ☆☆ UML Support UML支持插件 ☆☆ Nyan Progress Bar 彩虹进度条插件 ☆☆ Background Image Plus 背景图片 ☆ Power mode II 抖动气泡 ☆ Activate-power-mode 抖动气泡 ☆","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十五）：经验篇","slug":"IDEA快捷键拆解系列（十五）：经验篇","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/03/22/IDEA快捷键拆解系列（十五）：经验篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/22/IDEA快捷键拆解系列（十五）：经验篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十五篇。 &emsp;&emsp;本文整理了一些博主本人在学习工作中比较常用到的快捷键，有需要的可以参考一下，也欢迎留言补充。 类型 快捷键 描述 1. 查找 Ctrl + N 查找类文件 2. 查找 Ctrl + Shift + N 查找文件 3. 查找 Ctrl + F 当前文件查找 4. 查找 Ctrl + R 当前文件查找和替换 5. 查找 Ctrl + Shift + F 全局查找 6. 查找 Ctrl + Shift + R 全局查找和替换 7. 查找 Ctrl + Shift + A 查找指定动作 8. 查找 Double Shift Search everywhere 类型 快捷键 描述 1. 定位 F2 定位到下一处的错误地方 2. 定位 Shift + F2 定位到上一处的错误地方 3. 定位 F3 跳转到下一同一内容处 4. 定位 Shift + F3 跳转到上一同一内容处 5. 定位 F4 跳转到引用处 6. 定位 F12 跳转到上一次光标所在的面板 7. 定位 Ctrl + Shift + F12 用于打开当前文件所在本地的文件夹 8. 定位 Ctrl + B 或者 Ctrl + 鼠标点击 跳转声明处 9. 定位 Ctrl + Alt + B 跳转实现处 10. 定位 Ctrl + Shift + B 跳转返回值类型的声明处 11. 定位 Ctrl + G 跳转指定行 12. 定位 Ctrl + U 跳转父类 13. 定位 Ctrl + Shift + Alt + U 图表方式查看继承结构 14. 定位 Ctrl + Alt + Home 跳转项目的启动、入口类 15. 定位 Alt + Home 跳转顶部的项目导航条 16. 定位 Alt + 向左箭头 跳转左边的Tab 17. 定位 Alt + 向右箭头 跳转右边的Tab 18. 定位 Ctrl + Alt + 向左箭头 跳转上一次光标所在的位置 19. 定位 Ctrl + Alt + 向右箭头 跳转下一次光标所在的位置 20. 定位 Alt + Shift + Enter 将光标定位到上一行 21. 定位 Shift + Enter 将光标定位到下一行 22. 定位 Ctrl + Shift + Enter 将光标定位到方法外 23. 定位 Ctrl + 向左箭头 将光标定位到头部 24. 定位 Ctrl + 向右箭头 将光标定位到尾部 25. 定位 Ctrl + ] 将光标定位到代码块开始处 26. 定位 Ctrl + [ 将光标定位到代码块结尾处 类型 快捷键 描述 1. 选择 Alt + J 选中下一处当前选择的内容 2. 选择 Shift + Alt + J 取消选中下一处当前选择的内容 3. 选择 Ctrl + Alt + Shift + J 全部选中当前文件中当前选择的内容 4. 选择 Ctrl + Tab Switcher 5. 选择 Ctrl + E 最近操作过的文件列表 6. 选择 Ctrl + Shift + E 最近修改过的文件列表 7. 选择 Ctrl + A 选择当前全部 8. 选择 Ctrl + W 逐层往外扩展并选中内容 9. 选择 Ctrl + Shift + W 取消逐层往外扩展选中的内容 10. 选择 Ctrl + Shift + 向左箭头 从光标处起，依次往左选中内容 11. 选择 Ctrl + Shift + 向右箭头 从光标处起，依次往右选中内容 12. 选择 Shift + Home 从光标处起，一次选中至本行的头部 13. 选择 Shift + End 从光标处起，一次选中至本行的尾部 14. 选择 Ctrl + Shift + 空格键 智能代码提示 类型 快捷键 描述 1. 查看 Alt + Q 查看类定义信息 2. 查看 Ctrl + P 查看参数定义 3. 查看 Ctrl + Q 查看Documentation 4. 查看 Ctrl + F12 查看当前类结构 5. 查看 Ctrl + Shift + V 查看剪贴板 6. 查看 Ctrl + H 查看类的层次关系 7. 查看 Ctrl + Shift + H 查看方法的层次关系 8. 查看 Ctrl + Alt + H 查看方法的调用层次结构 9. 查看 Ctrl + Shift + I 弹框查看方法实现 类型 快捷键 描述 1. 编辑 Ctrl + Z 撤销 2. 编辑 Ctrl + Shift + Z 取消撤销 3. 编辑 Ctrl + X 剪切 4. 编辑 Ctrl + C 复制 5. 编辑 Ctrl + V 粘贴 6. 编辑 CTRL + D 拷贝当前行到下一行 7. 编辑 Ctrl + Y 删除当前行 8. 编辑 Delete 删除 9. 编辑 Alt + Delete 带检查的安全删除，可用于方法 10. 编辑 Ctrl + Shift + U 英文大小写切换 11. 编辑 Ctrl + O 覆盖父类方法 12. 编辑 Ctrl + I 实现接口方法 13. 编辑 Alt + Enter 最常用的快捷键，含包选择导入，帮助创建等 14. 编辑 Alt + Insert 在包中就是选择文件类型用于新建；在文件中就是添加构造器，Getter/Setter,toString实现等 15. 编辑 Ctrl + Alt + Insert 在当前文件夹下选择文件类型用于创建 16. 编辑 Ctrl + Alt + T 选择并进行代码包围 17. 编辑 Ctrl + J 插入Live Template 18. 编辑 Ctrl + Alt + J 选择Live Tmeplate 19. 编辑 Ctrl + 斜杠 单行注释 20. 编辑 Ctrl + Shift + 斜杠 多行注释 21. 编辑 Ctrl + Alt + L 格式化代码 22. 编辑 Ctrl + Alt + O 去掉未使用的导包 23. 编辑 Alt + 向上箭头 定位到上一个方法 24. 编辑 Alt + 向下箭头 定位到下一个方法 25. 编辑 Ctrl + Shift + 向上箭头 整行（方法）上移 26. 编辑 Ctrl + Shift + 向下箭头 整行（方法）下移 27. 编辑 Ctrl + Shift + Alt + 向上箭头 定位到上一处修改过的地方 28. 编辑 Ctrl + Shift + Alt + 向下箭头 定位到下一处修改过的地方 29. 编辑 Ctrl + Shift + T 创建单元测试 30. 编辑 Ctrl + Shift + J 转换为单行连接 31. 编辑 Ctrl + Delete 从光标处往后删除 32. 编辑 Ctrl + Backspace 从光标处往前删除 类型 快捷键 描述 1. 切換 Ctrl + F4 关闭当前Tab 2. 切換 Ctrl + Shift + ] 切换到下一个项目 3. 切換 Ctrl + Shift + [ 切换到上一个项目 4. 切換 Shift + ESC 关闭、隐藏当前面板 5. 切換 Ctrl + Shift + F12 关闭、隐藏所有面板 类型 快捷键 描述 1. 重构 F5 拷贝 2. 重构 F6 移动 3. 重构 Shift + F6 重命名 4. 重构 Ctrl + Alt + Shift + T 重构当前 5. 重构 Ctrl + Alt + V 抽取变量 6. 重构 Ctrl + Alt + C 抽取常量 7. 重构 Ctrl + Alt + F 抽取字段 8. 重构 Ctrl + Alt + P 抽取参数 9. 重构 Ctrl + Alt + M 抽取方法 10. 重构 Ctrl + Alt + N 内联 11. 重构 Ctrl + F6 修改签名 类型 快捷键 描述 1. Run Shift + F10 普通运行当前 2. Run Shift + F9 Debug运行当前 3. Run Alt + Shift + F10 普通运行所选 4. Run Alt + Shift + F9 Debug运行所选 5. Run Ctrl + F2 停止当前运行 类型 快捷键 描述 1. VCS Alt + 反引号 VCS操作 2. VCS Ctrl + T 拉取远程仓库 3. VCS Ctrl + K 提交本地暂存区 4. VCS Ctrl + M 查看提交信息历史列表 5. VCS Ctrl + Alt + A 添加版本控制 6. VCS Ctrl + Shift + K 提交远程仓库 7. VCS Ctrl + Alt + Z 撤销当前的修改 8. VCS Ctrl + Enter commit、提交 9. VCS Alt + Shift + C 查看最近的修改 类型 快捷键 描述 1. 编译 Ctrl + F9 编译项目 2. 编译 Ctrl + Shift + F9 编译当前 类型 快捷键 描述 1. 书签 F11 添加、取消书签 2. 书签 Ctrl + F11 带标志的书签 3. 书签 Shift + F11 查看所有书签 类型 快捷键 描述 1. 工具窗 Alt + 1 项目面板 2. 工具窗 Alt + 4 普通Run项目的面板 3. 工具窗 Alt + 5 Debug运行项目的面板 4. 工具窗 Alt + 6 TODO面板 5. 工具窗 Alt + 7 结构面板 6. 工具窗 Alt + 9 版本控制面板 7. 工具窗 Alt + 12 终端面板 8. 工具窗 Alt + F4 关闭当前IDEA 9. 工具窗 ESC 从工具窗返回到代码区 类型 快捷键 描述 1. 断点调试 Ctrl + F8 添加、取消断点 2. 断点调试 Ctrl + Shift + F8 查看所有断点 3. 断点调试 F8 跳到下一步 4. 断点调试 Alt + Shift + F8 强制跳到下一步 5. 断点调试 F7 进入代码内部 6. 断点调试 Shift + F8 退出代码内部 7. 断点调试 Alt + F9 运行到光标处 8. 断点调试 Ctrl + Alt + F9 强制运行到光标处 类型 快捷键 描述 1. 折叠展开 Ctrl + 减号 折叠当前方法 2. 折叠展开 Ctrl + 加号 展开当前方法 3. 折叠展开 Ctrl + Shift + 减号 折叠当前类的所有方法 4. 折叠展开 Ctrl + Shift + 加号 展开当前类的所有方法 类型 快捷键 描述 1. 配置设置 Ctrl + 反引号 配置开关 2. 配置设置 Ctrl + Alt + S 系统设置 3. 配置设置 Ctrl + Shift + Alt + S 项目结构设置","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十四）：Help篇","slug":"IDEA快捷键拆解系列（十四）：Help篇","date":"un33fin33","updated":"un22fin22","comments":true,"path":"2018/03/21/IDEA快捷键拆解系列（十四）：Help篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/21/IDEA快捷键拆解系列（十四）：Help篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十四篇。 &emsp;&emsp;以下是关于Help导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 Help 1. Find Action （ 通过描述动作，查找相关命令 ） Ctrl + Shift + A Help （ 查找相关帮助，含快捷键等 ） Getting started Keymap Reference （ PDF快捷键清单 ） Demos and screencasts Tip of the Day What’s New in IDEA （ 用于查看IDEA新特性 ） Productivity Guide Setting Summary Support Center （ 帮助中心 ） Submit Feedback （ 反馈提交 ） Show Log in Explorer （ IDEA日志 ） Edit Custom Properties （ 在idea.properties中添加个人配置 ） Edit Custom VM Options （ 在idea64.exe.vmoptions中添加个人启动配置 ） Debug Log Settings Register （ 注册 ） Check for Update （ 检查更新 ） JRebel… （ Jrebel插件 ） About","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十三）：Window篇","slug":"IDEA快捷键拆解系列（十三）：Window篇","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2018/03/20/IDEA快捷键拆解系列（十三）：Window篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/20/IDEA快捷键拆解系列（十三）：Window篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十三篇。 &emsp;&emsp;以下是关于Window导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 Window Quick Run Root Maven Goal Ctrl + Shift + Alt + R Quick Run Maven Goal Ctrl + Alt + R Store Current Layout as Default （ 存储当前为默认布局 ） Restore Default Layout （ 还原默认布局 ） Shift + F12 Active Tool Window （Tool Windows相关） Hide Active Tool Window（ 隐藏激活工具窗 ） Shift + Esc Hide Side Tool Windows Restore Windows （ 还原窗口 ） Ctrl + Shift + F12 Close Active Tab （ 关闭激活的Tab ）Ctrl + Shift + F4 Jump to Last Tool Window （ 定位到上一个操作工具窗 ） F12 Maximize Tool Window （ 最大化工具窗口 ） Ctrl + Shift + 引号 Pinned mode （ 勾选上为固定模式的窗口（默认），不勾选上当离开当前窗口时会隐藏 ） Docked mode （ 勾选上为对接模式的窗口（默认），不勾选上当离开当前窗口时会隐藏 ） Floting mode （ 勾选上为悬浮模式的窗口 ） Windowed mode Split mode Group Tabs Resize Stretch to Left Ctrl + Shift + 向左箭头 Stretch to Right Ctrl + Shift + 向右箭头 Stretch to Top Ctrl + Shift + 向上箭头 Stretch to Bottom Ctrl + Shift + 向下箭头 Editor Tabs （Tabs相关） Select Next Tab （ 切换到下一个Tab ） Alt + 向右箭头 Select Previous Tab （ 切换到上一个Tab ） Alt + 向左箭头 Pin Active Tab （ 为当前窗口添加Pin ） Show Hidden Tabs Close （ 关闭当前 ） Ctrl + F4 Close Others Close All （ 关闭所有 ） Close Unmodified （ 关闭未修改的 ） Close All But Pinned （ 关闭所有但除了有Pin的 ） Reopen Closed Tab （ 重新打开关闭的窗口 ） Move Right （ 分割到右边窗口 ） Move Down （ 分割到下边窗口 ） Change Splitter Oritentation （ 修改分割方向，就是如果是右边窗口就换到下边，下边窗口就换到右边 ） Unsplit （ 取消当前分割窗口 ） Unsplit All （ 取消全部分割窗口 ） Goto Next Splitter （ 跳转下一个分割窗口 ） Goto Previous Splitter （ 跳转前一个分割窗口 ） Tabs Placement （ 对应Tab窗口所在位置，默认是: Top ） Top Bottom Left Right None Show Tabs In Single Row Sort Tabs By Filename （ Tab窗口按文件名排序 ） Open New Tabs At The End Natifications Close First Close All Background Tasks Show Auto Show Next Project Window （切换到下一个项目窗口） Ctrl + Alt + ] Previous Project Window （切换到前一个项目窗口） Ctrl + Alt + [","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十二）：VCS篇","slug":"IDEA快捷键拆解系列（十二）：VCS篇","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2018/03/19/IDEA快捷键拆解系列（十二）：VCS篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/19/IDEA快捷键拆解系列（十二）：VCS篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十二篇。 &emsp;&emsp;以下是关于VCS导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 VCS Local history Show History （ 查看本地历史 ） Show History for Selection （ 查看所选文件的本地历史 ） Put Label VCS Operations Popup （ 弹出版本控制操作窗 ） Alt + 反引号 Commit Changes （ 提交修改，用Git话是提交到本地暂存区 ） Ctrl + K Update Project （ 项目更新，用Git话是从Remote拉取代码 ） Ctrl + T Integrate Project Refresh File Status Show Changes （ 查看本地修改列表 ） Ctrl + Shift + Alt + D Git Commit File （ 进行提交修改 ） Ctrl + K Add （ 添加版本控制 ） Ctrl + Alt + A Annotate （ 显示/隐藏注释 ） Show Current Revision（ 查看当前版本号 ） Compare with the Same Repository Version （ 与当前远程仓库的当前文件进行对比 ） Compare with Latest Repository Version （ 与当前最新仓库的当前文件进行对比 ） Compare with （ 弹出版本历史列表进行选择对比 ） Compare With Branch （ 弹出分支进行选择对比 ） Show history （ 查看当前文件的Git提交修改历史 ） Show History for Selection （ 查看当前选择内容的Git提交修改历史） Revert （ 撤销修改 ） Ctrl + Alt + Z Resolve Conflicts Branches （ 分支相关操作 ） Tag （ 标签相关操作 ） Merge Changes （ 合并修改 ） Stash Changes （ 暂存修改 ） UnStash Changes （ 取消暂存修改 ） Reset HEAD Remotes Clone Fetch Pull Push （ 从本地暂存区提交到Remote ） Ctrl + Shift + K Rebase Rebase my GitHub fork Create Pull Request Create Patch Apply Patch Apply Patch from Clipboard Shelve Changes Checkout from Version Control （ 从版本控制中检出项目 ） Github Git Mercurial Subversion TFS Import into Version Control （ 导入项目到版本控制 ） Import into CVS Create Git Repository （ 创建Git出库 ） Import into Subversion （ 导入到SVN ） Create Mercurial Repository Share Project On Github （ 分享项目到Github ） Browse VCS Repository Browse VCS Repository Show Git Repository Log Browse Subversion Repository Sync Settings","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十一）：Tools篇","slug":"IDEA快捷键拆解系列（十一）：Tools篇","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/03/18/IDEA快捷键拆解系列（十一）：Tools篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/18/IDEA快捷键拆解系列（十一）：Tools篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十一篇。 &emsp;&emsp;以下是关于Tools导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 Tools Tasks &amp; Contexts Switch Task Alt + Shift + T Open Task Alt + Shift + N Close Active Task Alt + Shift + W Edit ‘Default tack’ Add changelist for ‘Default task’ Show Description Open in Browser Alt + Shift + B Analyze Stacktrace From Task - Configure Servers Save Context （ 保存当前编辑区状态 ） Alt + Shift + S Load Context （ 加载某一保存的编辑区状态 ） Alt + Shift + L Clear Context （ 清空编辑区状态 ） Alt + Shift + X Save Live as Template （ 将当前设为Live Template ） Generate JavaDoc （ 生成JavaDoc ） Save Project as Template （ 将项目设为Template ） Manage Project Templates （ 管理项目Template ） 6. Capture Memory Snapshot 阿里编码规约 （ Alibaba Java Coding Guidelines plugin ） Deployment （ 部署，可选择连接FTP、SFTP等 ） Upload to Default Server Upload to Ctrl + Alt + Shift + X Download from Default Server Download from Compare Local File with Deployed Version Sync Local Subtree with Deployed Sync with Deployed to Configuration Options Automatic Upload Browse Remote Host Test RESTful Web Service （ 用于进行接口测试，类似于”Postman” ） Groovy Console WebServices Generate Java Code From Wsdl ShowDeployed Web Services Axis… Start SSH session （ 开启ssh会话连接 ）","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（十）：Run篇","slug":"IDEA快捷键拆解系列（十）：Run篇","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2018/03/17/IDEA快捷键拆解系列（十）：Run篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/17/IDEA快捷键拆解系列（十）：Run篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第十篇。 &emsp;&emsp;以下是关于Run导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 Run Run current file （ 运行当前文件 ） Shift + F10 Debug current file （ Debug运行当前文件 ） Shift + F9 Run File with Coverage （ 以统计覆盖的形式运行当前文件 ） Run with JRebel File （ JRebel插件，以普通形式运行 ） Debug with JRebel File （ JRebel插件，以Debug形式运行 ） JREBEL synchronized project with remote server Run （ 选择文件运行 ） Alt + Shift + F10 Debug （ 选择文件Debug运行 ） Alt + Shift + F9 Attach to Local Process Edit Configurations （ 配置编辑 ） Import Test Results From File Stop （ 关闭运行 ） Ctrl + F2 Show Running List （ 查看运行列表 ） Reload Changed Classes Step Over （ 跳到下一步 ） F8 Force Step Over （ 强制跳到下一步） Alt + Shift + F8 Step Into （ 进入代码内部 ） F7 Force Step Into （ 强制进入代码内部 ） Alt + Shift + F7 Smart Step Into （ 智能进入代码内部 ） Shift + F7 Step Out （ 退出代码内部 ） Shift + F8 Run to Cursor （ 运行到光标处 ） Alt + F9 Force Run to Cursor （ 强制运行到光标处 ） Ctrl + Alt + F9 Drop Frame Pause Program Resume Program F9 Evaluate Expression Alt + F8 Quick Evaluate Expression Ctrl + Alt + F8 Show Execution Point Alt + F10 Toggle Line Breakpoint （ 添加/取消行断点，断点会在当前行一直存在 ） Ctrl + F8 Toggle Method Breakpoint （ 添加/取消方法断点，断点会在整个方法内存在 ） Toggle Temporary Line Breakpoint （ 添加/取消临时断点，断点会在使用一次之后消失 ） Ctrl + Shift + Alt + F8 Toggle Breakpoint enabled View Breakpoints （ 查看所有断点 ） Ctrl + Shift +F8 Get thread dump","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（九）：Build篇","slug":"IDEA快捷键拆解系列（九）：Build篇","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/03/16/IDEA快捷键拆解系列（九）：Build篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/16/IDEA快捷键拆解系列（九）：Build篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第九篇。 &emsp;&emsp;以下是关于Build导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 Build Build Project （ 项目构建 ） Ctrl + F9 Build Module （ 模块构建 ） Recompile （ 重新编译 ） Ctrl + Shift + F9 4. Rebuild Project （ 项目重新构建 ） 5. Generate Ant Build Build Artifacts","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（八）：Refactor篇","slug":"IDEA快捷键拆解系列（八）：Refactor篇","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2018/03/15/IDEA快捷键拆解系列（八）：Refactor篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/15/IDEA快捷键拆解系列（八）：Refactor篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第八篇。 &emsp;&emsp;以下是关于Refactor导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 Refactor Refactor This （ 重构当前 ） Ctrl + Alt + Shift + T Rename （ 重命名 ） Shift + F6 Rename File Change Signature （ 修改方法、类的签名，含参数、返回值类型等 ） Ctrl + F6 Type Migration （ 类型迁移 ） Ctrl + Shift + F6 Make Static （ 添加Static关键字 ） Convert To Instance Method （ 转换为实例方法 ） Move （ 移动文件 ） F6 Copy （ 拷贝文件 ） F5 Safe Detele （ 安全删除，可用在方法上进行快速删除 ） Alt + Delete Extract（ 提取 ） Variable （ 变量 ） Ctrl + Alt + V Constant （ 常量 ） Ctrl + Alt + C Filed （ 类字段 ） Ctrl + Alt + F Parameter （ 参数 ） Ctrl + Alt + p Functional Parameter （ 函数式参数 ） Ctrl + Alt + Shift + P Parameter Object Mehtod （ 方法 ） Ctrl + Alt + M Type Parameter Method Object Delegate Interrface Superclass Subquery ad CTE Inline （ 转换为内联、方法链形式的调用 ） Ctrl + Alt + N Find and Replace Code Duplicates Invert Boolean Pull Members Up Push Members Down Push ITDs In Use Interface Where Possible Replace Inheritance with Delegation Remobe Middleman Wrap Method Return Value Convert Anonymous to Inner Encapsulate Fields （ 封装字端，用于生成Getter/Setter ） Replace Temp With Query Replace Constructor with Factory Method Replace Constructor with Builder Generify Migrate Lombok ( Lombok插件：添加 )- Default @Date Default @Getter Default @Setter Default @EqualsAndHashcode Default @ToString @Log (and friends) Delombok ( Lombok插件：删除 )- All lombok annotations @Data @Value @Wither @Delegate @Builder @Constructors @Getter @Setter @EqualsAndHashcode @ToString @Log (and friends) Internationalize（国际化）","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（七）：Analyze篇","slug":"IDEA快捷键拆解系列（七）：Analyze篇","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2018/03/14/IDEA快捷键拆解系列（七）：Analyze篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/14/IDEA快捷键拆解系列（七）：Analyze篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第七篇。 &emsp;&emsp;以下是关于Analyze导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 Analyze Inspect Code （ 代码分析 ） Code Cleanup （ 代码清理 ） Run Inspection by Name Ctrl + Alt + Shift + I Configure Current File Analysis Ctrl + Alt + Shift + H View Offline Inspection Results Infer Nullity （ 推断无效代码 ） Locate Duplicates Calculate Metrics （ 指标计算 ） 9. Show Coverage Data Ctrl + Alt + F6 Analyze Dependencies （ 分析依赖 ） Analyze Backward Dependencies Analyze Module Dependencies（ 分析模块依赖 ） Analyze Dependency Matrix Analyze Cyclic Dependencies Analyze Data Flow to Here Analyze Data Flow from Here Analyze Stacktrace FindBugs （FindBugs插件） Analyze Current File Ctrl + Alt + Shift + F Analyze Class （ non-anonymous ） under Cursor: Ctrl + Alt + Shift + Analyze Module Files Analyze Project Files Analyze All Modified Files: Alt + Shift + C Analyze changelist files: Alt + Shift + A","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（六）：Code篇","slug":"IDEA快捷键拆解系列（六）：Code篇","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2018/03/13/IDEA快捷键拆解系列（六）：Code篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/13/IDEA快捷键拆解系列（六）：Code篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第六篇。 &emsp;&emsp;以下是关于Code导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 Code Override Methods （ 重写覆盖方法 ） Ctrl + O Implements Methods （ 实现接口方法 ） Ctrl + I Delegate Methods Gengrate （ 用于生成Construct、Getter/Setter、toString等） Alt + Insert Surround With （ 生成包围代码 ） Ctrl + Alt +T Unwarp/Remove （ 取消代码包围 ） Ctrl + Shift + Delete Completion Basic Ctrl + 空格 SmartType （ 智能选择并实现 ） Ctrl + Shift + 空格 Cyclic Expand Word （ 循环往上选择单词 ） Alt + / Cyclic Expand Word （Backwrad）（ 循环往下选择单词 ） Alt + Shift + / Folding Expand （ 方法展开 ） Ctrl + 加号 Collapse （ 方法折叠 ） Ctrl + 减号 Expand Recursively （ 同上，方法展开 ） Ctrl + Alt + 加号 Collapse Recursively （ 同上，方法折叠 ） Ctrl + Alt + 减号 Expand All （ 全部方法展开 ） Ctrl + Shift + 加号 Collapse All （ 全部方法折叠 ） Ctrl + Shift + 减号 Expand to level… Expand all to level… Expand doc comments （ 展开Java doc注释 ） Collapse doc comments （ 折叠Java doc注释 ） Fold Selection / Remove region Ctrl + 句点 Fold Code Block Ctrl + Shift + 句点 Insert Live Template （ 选择Live Templates模板 ） Ctrl + J Surround with Live Template （ 选择Live Templates模板 ） Ctrl + Alt + J Comment with Line Comment （ 行注释 ） Ctrl + / Comment with Block Comment （ 块注释 ） Ctrl + Shift + / Reformat Code （ 格式化代码 ） Ctrl + Alt + L Show Reformat File Dialog （ 弹出格式化弹框 ） Ctrl + Alt + Shift + L Auto-Indent Lines Ctrl + Alt + I Optimize Imports （ 去除未引用的包导入声明 ） Ctrl + Alt + O Rearrange Code （ 重新整理代码 ） Move Statement Down （ 方法、代码下移 ） Ctrl + Shift + 向下箭头 Move Statement Up （ 方法、代码上移 ） Ctrl + Shift + 向上箭头 Move Element Left Ctrl + Alt + Shift + 向左箭头 Move Element Rigth Ctrl + Alt + Shift + 向右箭头 Move Line Down Alt + Shift + 向下箭头 Move Line Up Alt + Shift + 向上箭头 Update Copyright","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（五）：Navigate篇","slug":"IDEA快捷键拆解系列（五）：Navigate篇","date":"un11fin11","updated":"un66fin66","comments":true,"path":"2018/03/12/IDEA快捷键拆解系列（五）：Navigate篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/12/IDEA快捷键拆解系列（五）：Navigate篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第五篇。 &emsp;&emsp;以下是关于Navigate导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 Navigate Class （ 查找类 ） Ctrl + N File （ 查找文件 ） Ctrl + Shift + N Symbol （ 查找标志符号，常用与查找方法名，变量名等 ） Ctrl + Shift +Alt + N Custom Folding Ctrl + Alt + 句点 Line/Column （ 跳转指定行 ） Ctrl + G Back （ 跳转前一个编辑过的位置 ） Ctrl + Alt + 左箭头 Forward （ 跳转后一个编辑过的位置 ） Ctrl + Alt + 右箭头 Last Edit Location （ 同上，跳转前一个编辑过的位置 ） Ctrl + Shift + Backspace Next Edit Location Bookmarks Toogle Bookmark （ 定义书签 ） F11 Toogle BookMark With Mnemonic （ 定义带标记的书签 ） Ctrl + F11 Show Bookmarks （ 查看所有书签 ） Shift + F11 Next Bookmark （ 上一个书签 ） previous Bookmark （ 下一个书签 ） Select In （ 弹出多功能的Select Target面板 ） Alt + F1 Jump to Navigation Bar （ 跳转到项目导航条 ） Alt + Home Declaration （ 跳转到声明处，同F4 ） Ctrl + B Implementations （ 跳转到实现处 ） Ctrl + Alt + B Type Declaration Ctrl + Shift + B Super Class （ 跳转父类 ） Ctrl + U Test （ 创建单元测试 ） Ctrl + Shift + T Related Symbol （ 跳转项目的启动入口类 ） Ctrl + Alt + Home File structure （ 查看文件（类）结构 ） Ctrl + F12 File Path （ 弹出所在的本地文件路径 ） Ctrl + Alt+ F12 Type Hierarchy （ 类的层级结构 ） Ctrl + H Method Hierarchy （ 方法的层级结构 ） Ctrl + Shift + H Call Hierarchy （ 调用层级结构 ） Ctrl + Alt+ H Next Highlighted Error （ 下一个高亮的错误 ） F2 Previous Highlighted Error （ 前一个高亮的错误 ） Shift + F2 Next Method （ 下一个方法 ） Alt + 向上箭头 Previous Method （ 上一个方法 ） Alt + 向下箭头","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（四）：View篇","slug":"IDEA快捷键拆解系列（四）：View篇","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2018/03/11/IDEA快捷键拆解系列（四）：View篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/11/IDEA快捷键拆解系列（四）：View篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第四篇。 &emsp;&emsp;以下是关于View导航项及其每一子项的拆解介绍，其中，加粗部分的选项是博主认为比较重要的。 View Tool Windows（工具窗） Project （项目） Alt + 1 Favorites （标签） Alt + 2 Run （项目运行） Alt + 4 Debug （项目Debug运行）Alt + 5 TODO （TODO） Alt + 6 Structure （结构） Alt + 7 Version Control （版本控制） Alt + 9 Terminal （终端） Alt + 12 Quick Definition （查看方法，类or变量的定义） Ctrl + shift +I Show siblings Quick Documentation （查看JavaDoc文档） Ctrl + Q Show ByteCode （查看编译后的文件字节码） Parameter Info （查看参数信息） Ctrl + P Expression Type （查看表达式类型） Ctrl + Shift + P Context Info （查看上下文） Alt +Q Jump to Source （快速跳转到类、变量定义处，相当于Ctrl + 鼠标点击，也相当与Ctrl + B） F4 Recent Files （列出最近打开的文件列表） Ctrl + E Recently changed Files （列出最近编辑过的文件列表） Ctrl + Shift + E Recent Changes （最近修改） Alt + Shift + C Compare With Ctrl + D Compare With Clipboard 15. Quick Switch Scheme （快读修改计划、组合）Ctrl + 后引号 Toolbar （用于上面的工具栏展示状态切换） Tool Buttons （用于周边的工具窗口展示状态切换） Status Bar （用于最下边的状态栏窗口展示状态切换） Navigation Bar （用于导航条的展示状态切换） Active Editor Show Whitespaces （展示空白） Show Line Numbers （展示行号） Show Gutter Icons （展示行号旁边的指导图标） Show Indent Guides （展示缩进的指导） Use Soft Wraps （使用合适的自动换行) Show Import Popups （选中则表示要展示手动导入的弹框，否则就会进行自动匹配导入） BiDi Text Direction Content-based Left-to-Right Right-to-Left Enter(Exit) Presentation Mode （展示模式） Enter Distraction Free Mode Enter(Exit) Full Screen （全屏模式）","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（三）：Edit篇","slug":"IDEA快捷键拆解系列（三）：Edit篇","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2018/03/10/IDEA快捷键拆解系列（三）：Edit篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/10/IDEA快捷键拆解系列（三）：Edit篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第三篇。 &emsp;&emsp;以下是关于Edit导航项及其每一子项的拆解，其中，加粗部分的选项是博主认为比较重要的。 Edit Undo （ 撤销 ） Ctrl + Z Redo （ 重做还原、取消撤销 ） Ctrl + Shift + Z Cut （ 裁剪 ） Ctrl + X Copy （ 复制 ） Ctrl + C Copy Path （ 复制绝对路径 ） Ctrl + Shift + C Copy as Plain Test Copy Reference （ 复制相对路径 ） Ctrl + Alt + Shift + C Paste （ 粘贴 ） Ctrl + V Paste from History （ 从粘贴板历史选择粘贴，可使用对应数字进行快速选择 ） Ctrl + Shift + V Paste Simple （ 简单粘贴 ） Ctrl + Alt + Shift + V Delete （ 删除 ） Delete Find Find （ 在当前文件查找 ） Ctrl + F Replace （ 在当前文件查找替换 ） Ctrl + R Find Next / Move to Next Occurrence （ 让光标快速移动到所选内容的下一个出现处 ） F3 Find Previous / Move to Previoud Occurrence （ 让光标快速移动到所选内容的上一个出现处 ） Shift + F3 Find Word at Caret Ctrl + F3 Select All Occurrences （ 选择当前选中内容在当前文件的全部内容。举个栗子：当前文件选中了“User”，那么当前文件中的所有“User”都会被选择，可用于快速更改或删除 ） Ctrl +Alt + Shift + J Add Selection for Next Occurrence （ 依次往下开始选择当前选中内容的下一个同一内容 ） Alt + J Unselect Occurrence （ 依次往下取消选择当前选中内容的下一个同一内容 ） Alt + Shift + J Find in Path （ 在路径中查找，全局查找 ） Ctrl + Shift + F Replace in Path （ 在路径中查找替换，全局查找替换 ） Ctrl + Shift + R Search Structurally （ 通过模板结构查找 ） Replace Structurally （ 替换模板结构 ） Find Usages （ 查找所选内容在项目中的所有出现处 ） Alt + F7 Find Usages Settings Ctrl + Alt + Shift + F7 Show Usages （ 在项目中查找展示所选内容的全部使用处 ） Ctrl + Alt + F7 Find Usages in File （ 在当前文件中查找所选内容的使用处 ） Ctrl + F7 Highlight Usages in File （ 在当前文件中高亮所选内容使用处 ） Ctrl + Shift + F7 Recent Find Usages Find by XPath Ctrl + Alt + X , F Macros （ 类似于录像机器人功能，用于记录操作，然后点播放可以还原记录的操作过程 ） Play Back Last Macro Start Macro Recording Edit Macros Play Saved Macros Column Selection Mode （ 行、列选择模式，默认是行选择模式 ） Alt + Shift + Insert Select All （ 选择全部 ） Ctrl + A Extend Selection （ 逐渐扩展选择区域 ） Ctrl + W Shrink Selection （ 逐渐缩减选择区域 ） Ctrl + Shift + W Complete Current Statement （ 把光标快速定位到当前代码块外 ） Ctrl + Shift + Enter Join Lines （ 用于折叠代码到一行 ） Ctrl + Shift + J Fill Paragraph Duplicate Kibe （ 向下复制整行 ） Ctrl + D Indent Selection （ 整行缩进 ） Tab Unindent Line or Selection （ 整行缩退 ） Shift + Tab Toggle Cas （ 大小写切换 ） Ctrl + Shift + U Concert Indents （ 切换缩进风格 ） To Spaces To Tabs Next Parameter Tab Previous Parameter Shift + Tab 28. Encode XML/HTML Special Characters Shift-Up Ctrl + Alt + Shift + 句点 Shift-Down Ctrl + Alt + Shift + 逗号 Shift-Up more （ 快速修改驼峰单词定义，可转换为按“-”或者“_”分隔 ） Ctrl + Alt + Shift + K Shift-Down more （ 选择当前选中内容在当前文件的全部内容。举个栗子：当前文件选中了“User”，那么当前文件中的所有“User”都会被选择，可用于快速更改或删除 ） Ctrl + Alt + Shift + J Edit as Table","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"IDEA快捷键拆解系列（二）：File篇","slug":"IDEA快捷键拆解系列（二）：File篇","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2018/03/09/IDEA快捷键拆解系列（二）：File篇/","link":"","permalink":"https://blog.mariojd.cn/2018/03/09/IDEA快捷键拆解系列（二）：File篇/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第二篇。 &emsp;&emsp;以下是关于File导航项及其每一子项的拆解，其中，加粗部分的选项是博主认为比较重要的。 File New Project （ 新建项目 ） Project from Existing Sources （ 从本地导入项目，包括Eclipse、Maven、Gradle项目等 ） Project from Version Control （ 版本控制，含以下五种版本管理系统 ） GitHub Git Mercurial Subversion TFS Module（ 新建子模块 ） Module from Existing Sources （ 从本地导入模块，包括Eclipse、Maven、Gradle项目等 ） Java Class Aspect File Scratch File Ctrl + Alt + Shift + Insert Directory FXML File package-info.java HTML File Styleshoot JavaScript File TypeScript File CFML/CFC file CoffeeScript File JavaFXApplication Singleton （ 新建单例类（ 饿汉模式 ）） XSLT Stylesheet - Edit File Templates （ 编辑文件模板 ） GUI Form （ Swing开发中，用于快速创建GUI表单类 ） Dialog （ Swing开发中，用于创建GUI对话类 ） Form Snapshot Resource Bundle XML Configuration File （ 创建XML配置文件 ） JSP Tag Library Descriptor （ JSP标签库描述 ） Spring Config （ Spring配置文件 ） Diagram （ 图表建模 ） Java Class Diagram Module Dependencies Google Guice （ 谷歌开源的一款依赖注入框架 ） Guice Module Guice Provider Guice Binding Annotation Guice Scope Annotation Guice Method Interceptor Data Source （ 数据源 ） Open（ 从本地打开 ） Open URL（ 通过URL打开 ） Open Recent… （ 选择最近的项目打开 ） Close Project （ 关闭项目，回到欢迎界面 ） Settings （ 设置 ） Ctrl + Alt + S Project Structure ( 项目结构 ） Ctrl + Alt + Shift + S Other Settings ( 其它配置 ) Default Settings （ 默认设置 ） Default Project Structure ( 默认项目结构 ） Import Settings Export Settings Export to Eclipse （ 导出Eclipse项目 ） Settings Repository Save All Ctrl + S Synchronized Ctrl + Alt + Y Invalidate Caches/Restart ( 清除项目索引缓存 ) Export to HTML Print Add Favorites… File Encoding （ 设置文件编码 ） Line Separators… （ 设置行分隔符 ） Make File Read-only 22. Power Save Mode Exit （ 直接关闭所有的IDEA项目，跟Close Project的区别是不会再回到欢迎界面，可使用快捷键Alt + F4一个个的关闭 ）","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"Docker + PostgreSQL（10.1）主从环境搭建","slug":"Docker + PostgreSQL（10.1）主从环境搭建","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2018/03/08/Docker + PostgreSQL（10.1）主从环境搭建/","link":"","permalink":"https://blog.mariojd.cn/2018/03/08/Docker + PostgreSQL（10.1）主从环境搭建/","excerpt":"","text":"运行PostgreSQL主库docker run --name pgmaster -p 5432:5432 -e POSTGRES_PASSWORD=pgmaster -v $(pwd)/pgmaster:/var/lib/postgresql/data -d postgres 从库docker run --name pgslave -p 5433:5432 -e POSTGRES_PASSWORD=pgslave -v $(pwd)/pgslave:/var/lib/postgresql/data -d postgres 以下操作需进入主、从库对应的挂载目录执行 配置master（主库）编辑pg_hba.conf，在最下面添加如下：host replication &lt;replication_username&gt; &lt;slave_ip&gt;/32 md5 编辑postgresql.conf（亲测，非必须），更改如下：synchronous_standby_names = &apos;*&apos; 进入容器，登录PostgreSQL，创建复制用户并验证# 进入容器 docker exec -it pgmaster bash# 连接PostgreSQL psql -U postgres# 创建用户 set synchronous_commit =off; create role &lt;replication_username&gt; login replication encrypted password &apos;&lt;replication_username_password&gt;&apos;; # 验证用户 \\du 配置Slave（从库）编辑pg_hba.conf，在最下面添加如下：host replication &lt;replication_username&gt; &lt;master_ip&gt;/32 md5 编辑postgresql.conf（亲测，非必须），更改如下：hot_standby_feedback = on 建立recovery.conf，添加如下内容：standby_mode = &apos;on&apos;primary_conninfo = &apos;host=&lt;master_ip&gt; port=&lt;master_port&gt; user=&lt;replication_username&gt; password=&lt;replication_username_password&gt;&apos; 同步主从库并测试 停止PostgreSQL docker stop pgmaster &amp;&amp; docker stop pgslave 同步文件 方法1：rsync rsync -cva --inplace --exclude=*pg_xlog* $(pwd)/pgmaster/ &lt;slave_ip&gt;:$(pwd)/pgslave/ 方法2：pg_basebackup 先后启动主库、从库服务 docker start pgmaster &amp;&amp; docker start pgslave 连接测试 docker exec -it pgmaster bashpsql -U postgres -x -c &quot;select * from pg_stat_replication;&quot;","categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://blog.mariojd.cn/categories/PostgreSQL/"},{"name":"Docker","slug":"PostgreSQL/Docker","permalink":"https://blog.mariojd.cn/categories/PostgreSQL/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.mariojd.cn/tags/Docker/"},{"name":"主从搭建","slug":"主从搭建","permalink":"https://blog.mariojd.cn/tags/主从搭建/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://blog.mariojd.cn/tags/PostgreSQL/"}]},{"title":"Docker + MySQL（5.7）主从环境搭建","slug":"Docker + MySQL（5.7）主从环境搭建","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2018/03/07/Docker + MySQL（5.7）主从环境搭建/","link":"","permalink":"https://blog.mariojd.cn/2018/03/07/Docker + MySQL（5.7）主从环境搭建/","excerpt":"","text":"配置my.cnf 安装包安装的就找/etc/my.cnf进行添加 在挂载目录下建好对应的*.cn文件 [mysqld] log-bin=mysql-bin //[必须]启用二进制日志 server-id=222 //[必须]服务器唯一ID，默认是1，一般取IP最后一段 运行容器docker run –name mysqlmaster1 -v /root/mysql/conf/master1:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=mysqlmaster1 -p 3306:3306 -d mysql –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_cidocker run –name mysqlslave1 -v /root/mysql/conf/slave1:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=mysqlslave1 -p 3307:3306 -d mysql –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_cidocker run –name mysqlmaster2 -v /root/mysql/conf/master2:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=mysqlmaster2 -p 3308:3306 -d mysql –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_cidocker run –name mysqlslave2 -v /root/mysql/conf/slave2:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=mysqlslave2 -p 3309:3306 -d mysql –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci 配置账户在主库上创建一个复制账户GRANT REPLICATION SLAVE ON . TO ‘rep1’@’120.77.250.15’ IDENTIFIED BY ‘master1toslave1’;GRANT REPLICATION SLAVE ON . TO ‘rep2’@’120.77.250.15’ IDENTIFIED BY ‘master2toslave2’; 在master上执行show master status;记录File和Position信息 执行连接配置从库连接主库, 在从库上执行CHANGE MASTER TO MASTER_HOST=’120.77.250.15’,MASTER_PORT=3306,MASTER_USER=’rep1’,MASTER_PASSWORD=’master1toslave1’,MASTER_LOG_FILE=’mysql-bin.000003’,MASTER_LOG_POS=449;CHANGE MASTER TO MASTER_HOST=’120.77.250.15’,MASTER_PORT=3308,MASTER_USER=’rep2’,MASTER_PASSWORD=’master2toslave2’,MASTER_LOG_FILE=’mysql-bin.000003’,MASTER_LOG_POS=449; 开启同步 在从库启动 slave 线程开始同步: start slave; 检查从服务器复制功能状态: show slave status\\G; 设置从库只读mysql&gt; set global read_only=1; #1是只读，0是读写，对拥有super权限的账号是不生效的，所以在授权账号的时候尽量避免添加super权限mysql&gt; show global variables like “%read_only%”;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.mariojd.cn/categories/MySQL/"},{"name":"Docker","slug":"MySQL/Docker","permalink":"https://blog.mariojd.cn/categories/MySQL/Docker/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.mariojd.cn/tags/MySQL/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.mariojd.cn/tags/Docker/"},{"name":"主从搭建","slug":"主从搭建","permalink":"https://blog.mariojd.cn/tags/主从搭建/"}]},{"title":"Python学习资源整理（持续更新...）","slug":"Python学习资源整理（持续更新...）","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2018/03/05/Python学习资源整理（持续更新...）/","link":"","permalink":"https://blog.mariojd.cn/2018/03/05/Python学习资源整理（持续更新...）/","excerpt":"","text":"&emsp;&emsp;本文用于整理学习Python的在线资源，更多关于Python方面的知识和技术分享，请关注我的后续更新。 官方必备 Python官网 Pip Awesome Python(Python资源大全) Python 资源大全中文版 在线资源 菜鸟教程 慕课网 极客学院 伯乐在线 网易云课堂 实验楼 python中文学习大本营 技术博客 廖雪峰-python教程 Web开发 Django Flask Sanic Tornado webpy Bottle 网页爬虫 网页抓取 urllib Requests 网页解析 BeautifulSoup lxml PyQuery 自动化框架 Selenium 爬虫框架 Scrapy PySpider 数据科学 NumPy Pandas Matplotlib SciPy 图像识别 OpenCV 自然语言 NLTK 机器学习 Scikit-learn TensorFlow Keras 公众号 Python那些事 Python开发者 Python绿色通道 欢迎大家留言补充","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.mariojd.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.mariojd.cn/tags/Python/"},{"name":"学习资源","slug":"学习资源","permalink":"https://blog.mariojd.cn/tags/学习资源/"}]},{"title":"Mycat（实践篇 - 基于PostgreSQL的水平切分、主从复制、读写分离）","slug":"Mycat（实践篇 - 基于PostgreSQL的水平切分、主从复制、读写分离）","date":"un00fin00","updated":"un66fin66","comments":true,"path":"2018/03/04/Mycat（实践篇 - 基于PostgreSQL的水平切分、主从复制、读写分离）/","link":"","permalink":"https://blog.mariojd.cn/2018/03/04/Mycat（实践篇 - 基于PostgreSQL的水平切分、主从复制、读写分离）/","excerpt":"","text":"写在前面&emsp;&emsp;Mycat作为独立的数据库中间件，我们只需要进行相关的配置，就可以非常方便的帮我们实现水平切分、垂直切分、读写分离等功能，但PostgreSQL的主从复制需要我们通过其它方式实现。这里假设我们已经搭建好相关的环境，下面就开始我们的实践吧！ 准备环境 PostgreSQL(Version : 10.1)主从环境搭建 对应数据库建立（以下例子中使用的都是默认存在的postgres数据库，可以不用额外添加） 配置server.xml&lt;user name=\"postgresmycat\"&gt; &lt;property name=\"password\"&gt;postgresmycat&lt;/property&gt; &lt;property name=\"schemas\"&gt;postgresmycats&lt;/property&gt; &lt;/user&gt; 配置schema.xml &lt;schema name=\"postgresmycats\" checkSQLschema=\"false\" sqlMaxLimit=\"100\"&gt; &lt;table name=\"tb_user\" dataNode=\"mydn3,mydn4\" rule=\"user-mod-long\" /&gt; &lt;table name=\"tb_student\" dataNode=\"mydn3,mydn4\" rule=\"student-mod-long\" /&gt; &lt;/schema&gt; &lt;dataNode name=\"mydn3\" dataHost=\"myhost3\" database=\"postgres\" /&gt; &lt;dataNode name=\"mydn4\" dataHost=\"myhost4\" database=\"postgres\" /&gt;&lt;!-- 这里的dbDriver使用jdbc的方式来连接，用native方式似乎目前还不太兼容，试过了好像不可以 --&gt; &lt;dataHost name=\"myhost3\" maxCon=\"100\" minCon=\"10\" balance=\"3\" writeType=\"0\" dbType=\"postgresql\" dbDriver=\"jdbc\"&gt; &lt;heartbeat&gt;select user&lt;/heartbeat&gt;&lt;!-- 注意这里的心跳检测命令跟mysql的有点不同 --&gt; &lt;writeHost host=\"hostM3\" url=\"jdbc:postgresql://localhost:5432/postgres\" user=\"postgres\" password=\"xxx\"&gt; &lt;readHost host=\"hostS3\" url=\"jdbc:postgresql://localhost:5433/postgres\" user=\"postgres\" password=\"xxx\"/&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;dataHost name=\"myhost4\" maxCon=\"100\" minCon=\"10\" balance=\"3\" writeType=\"0\" dbType=\"postgresql\" dbDriver=\"jdbc\"&gt; &lt;heartbeat&gt;select user&lt;/heartbeat&gt; &lt;writeHost host=\"hostM4\" url=\"jdbc:postgresql://localhost:5434/postgres\" user=\"postgres\" password=\"xxx\" &gt; &lt;readHost host=\"hostS4\" url=\"jdbc:postgresql://localhost:5435/postgres\" user=\"postgres\" password=\"xxx\"/&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; dbDriver 属性&emsp;&emsp;指定连接后端数据库使用的 Driver，目前可选的值有 native 和 jdbc。使用 native 的话，因为这个值执行的是二进制的 mysql 协议，所以可以使用 mysql 和 maridb。其他类型的数据库则需要使用 JDBC 驱动来支持 引述《Mycat权威指南》里面的原话: 从 1.6 版本开始支持 postgresql 的 native 原始协议。如果使用 JDBC 的话需要将符合 JDBC4 标准的驱动 JAR 包放到 MYCAT\\lib 目录下，并检查驱动 JAR 包中包括如下目录结构的文件：META-INF\\services\\java.sql.Driver。在这个文件内写上具体的 Driver 类名，例如：com.mysql.jdbc.Driver。 &emsp;&emsp;所以，具体的解决方案就是找一个postgresql的jar包，然后丢到mycat的lib目录下，不然就会出现启动失败或者连接不到postgre数据库的异常情况。本例中用到的jar包是：postgresql-42.1.4.jar 配置rule.xml &lt;tableRule name=\"user-mod-long\"&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;mod-long&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=\"student-mod-long\"&gt; &lt;rule&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;algorithm&gt;mod-long&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt;&lt;function name=\"mod-long\" class=\"io.mycat.route.function.PartitionByMod\"&gt; &lt;property name=\"count\"&gt;2&lt;/property&gt;&lt;/function&gt; &emsp;&emsp;修改了配置文件后，别忘了重启Mycat，如果有异常出现，请通过查看logs目录下的日志文件进行排查。 项目搭建（SpringBoot + JPA） 准备：首次建表，设置application.yml中的spring.jpa.hibernate.ddl-auto属性为：create（JPA自动建表解决方案，使用update的话在连接mycat的时候会报找不到表的错误）。之后似乎必须更改为：none，否则使用其它属性都会报错（这里Mysql与PostgreSQL不同，似乎是一个未解决的bug，这也就意味着以后新增字段都要手动连上数据库进行添加了…） 添加application.yml（注意了，这里都是用连mysql的方式去配置，Mycat会在后端做好对其它数据库的连接）： spring: jpa: show-sql: true hibernate: ddl-auto: update naming: strategy: org.hibernate.cfg.ImprovedNamingStrategy properties: hibernate: dialect: org.hibernate.dialect.MySQL5Dialect datasource: url: jdbc:mysql://localhost:8066/postgresmycats?characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;rewriteBatchedStatements=true username: postgresmycat password: postgresmycat 添加User Entity @Entity@Table(name = \"tb_user\")@Datapublic class User &#123; @Id private Long id; private String name; private Integer gender;&#125; 添加Student Entity @Entity@Table(name = \"tb_student\")@Datapublic class Student &#123; @Id private Long id; private String name; @Column(unique = true) private Long userId;&#125; 添加UserDao public interface UserDao extends JpaRepository&lt;User, Long&gt; &#123; Page&lt;User&gt; findByNameLike(String name, Pageable pageable);&#125; 添加StudentDao public interface StudentDao extends JpaRepository&lt;Student, Long&gt; &#123; Page&lt;User&gt; findByNameLike(String name, Pageable pageable);&#125; 项目测试 测试添加 @Testpublic void testAdd() &#123; for (long i = 0; i &lt; 30; i++) &#123; User user = new User(); user.setId(i); user.setName(\"李四\" + i); user.setGender(i % 2 == 0 ? 1 : 0); userDao.save(user); Student student = new Student(); student.setId(System.currentTimeMillis() + i); student.setName(\"李四学生\" + i); student.setUserId(i); studentDao.save(student); &#125;&#125; 测试结果：数据按id取模的方式划分到了两个数据库中，同时从库同步了主库的数据 测试模糊查询+分页 @Testpublic void testFind() &#123; Pageable pageable = new PageRequest(0, 10, Sort.Direction.ASC, \"id\"); List&lt;User&gt; userList = userDao.findByNameLike(\"%李四1%\", pageable).getContent(); userList.forEach(System.out::println); Pageable pageable2 = new PageRequest(0, 10, Sort.Direction.ASC, \"userId\"); List&lt;Student&gt; studentList = studentDao.findByNameLike(\"%李四学生2%\", pageable2).getContent(); studentList.forEach(System.out::println);&#125; 测试结果：按照模糊匹配及id升序的方式输出结果 测试结果：读操作都走了从库 删除及修改请自行测试 参考链接 Mycat官网Mycat从零开始Mycat权威指南GitHub：Mycat-ServerWiki：Mycat-ServerIssues：Mycat-Servermysql中间件研究（Atlas，Cobar，TDDL）mysql中间件研究（Atlas，Cobar，TDDL，Mycat，Heisenberg，Oceanus，Vitess，OneProxy）","categories":[{"name":"数据库中间件","slug":"数据库中间件","permalink":"https://blog.mariojd.cn/categories/数据库中间件/"},{"name":"Mycat","slug":"数据库中间件/Mycat","permalink":"https://blog.mariojd.cn/categories/数据库中间件/Mycat/"}],"tags":[{"name":"Mycat","slug":"Mycat","permalink":"https://blog.mariojd.cn/tags/Mycat/"},{"name":"数据库中间件","slug":"数据库中间件","permalink":"https://blog.mariojd.cn/tags/数据库中间件/"},{"name":"实践篇","slug":"实践篇","permalink":"https://blog.mariojd.cn/tags/实践篇/"},{"name":"主从复制","slug":"主从复制","permalink":"https://blog.mariojd.cn/tags/主从复制/"},{"name":"读写分离","slug":"读写分离","permalink":"https://blog.mariojd.cn/tags/读写分离/"},{"name":"postgresql","slug":"postgresql","permalink":"https://blog.mariojd.cn/tags/postgresql/"}]},{"title":"Mycat（实践篇 - 基于Mysql的水平切分、主从复制、读写分离）","slug":"Mycat（实践篇 - 基于Mysql的水平切分、主从复制、读写分离）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2018/03/03/Mycat（实践篇 - 基于Mysql的水平切分、主从复制、读写分离）/","link":"","permalink":"https://blog.mariojd.cn/2018/03/03/Mycat（实践篇 - 基于Mysql的水平切分、主从复制、读写分离）/","excerpt":"","text":"写在前面&emsp;&emsp;Mycat作为独立的数据库中间件，我们只需要进行相关的配置，就可以非常方便的帮我们实现水平切分、垂直切分、读写分离等功能，但Mysql的主从复制需要我们通过其它方式实现。这里假设我们已经搭建好相关的环境，下面就开始我们的实践吧！ 准备环境 Mysql(Version : 5.7)主从环境搭建 对应数据库建立（以下例子中要建的数据库是：master1mycat 和 master2mycat） 配置server.xml&lt;user name=\"mysqlmycat\"&gt; &lt;property name=\"password\"&gt;mysqlmycat&lt;/property&gt; &lt;property name=\"schemas\"&gt;mysqlmycats&lt;/property&gt;&lt;/user&gt; 配置schema.xml &lt;schema name=\"mysqlmycats\" checkSQLschema=\"false\" sqlMaxLimit=\"100\"&gt; &lt;table name=\"tb_user\" dataNode=\"mydn1,mydn2\" rule=\"user-mod-long\" /&gt; &lt;table name=\"tb_student\" dataNode=\"mydn1,mydn2\" rule=\"student-mod-long\" /&gt; &lt;/schema&gt;&lt;dataNode name=\"mydn1\" dataHost=\"myhost1\" database=\"master1mycat\" /&gt; &lt;dataNode name=\"mydn2\" dataHost=\"myhost2\" database=\"master2mycat\" /&gt; &lt;dataHost name=\"myhost1\" maxCon=\"100\" minCon=\"10\" balance=\"3\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;writeHost host=\"hostM1\" url=\"localhost:3306\" user=\"root\" password=\"xxx\"&gt; &lt;readHost host=\"hostS1\" url=\"localhost:3307\" user=\"root\" password=\"xxx\"/&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;dataHost name=\"myhost2\" maxCon=\"100\" minCon=\"10\" balance=\"3\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;writeHost host=\"hostM2\" url=\"localhost:3308\" user=\"root\" password=\"xxx\" &gt; &lt;readHost host=\"hostS2\" url=\"localhost:3309\" user=\"root\" password=\"xxx\"/&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; 配置rule.xml &lt;tableRule name=\"user-mod-long\"&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;mod-long&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=\"student-mod-long\"&gt; &lt;rule&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;algorithm&gt;mod-long&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt;&lt;function name=\"mod-long\" class=\"io.mycat.route.function.PartitionByMod\"&gt; &lt;property name=\"count\"&gt;2&lt;/property&gt;&lt;/function&gt; &emsp;&emsp;修改了配置文件后，别忘了重启Mycat，如果有异常出现，请通过查看logs目录下的日志文件进行排查。 项目搭建（SpringBoot + JPA） 准备：首次建表，设置application.yml中的spring.jpa.hibernate.ddl-auto属性为：create（JPA自动建表解决方案，使用update的话在连接mycat的时候会报找不到表的错误）。为保证数据不被丢失，在建表之后可以更改为：update 添加application.yml： spring: jpa: show-sql: true hibernate: ddl-auto: update naming: strategy: org.hibernate.cfg.ImprovedNamingStrategy properties: hibernate: dialect: org.hibernate.dialect.MySQL5Dialect datasource: url: jdbc:mysql://localhost:8066/mysqlmycats?characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;rewriteBatchedStatements=true username: mysqlmycat password: mysqlmycat 添加User Entity @Entity@Table(name = \"tb_user\")@Datapublic class User &#123; @Id private Long id; private String name; private Integer gender;&#125; 添加Student Entity @Entity@Table(name = \"tb_student\")@Datapublic class Student &#123; @Id private Long id; private String name; @Column(unique = true) private Long userId;&#125; 添加UserDao public interface UserDao extends JpaRepository&lt;User, Long&gt; &#123; Page&lt;User&gt; findByNameLike(String name, Pageable pageable);&#125; 添加StudentDao public interface StudentDao extends JpaRepository&lt;Student, Long&gt; &#123; Page&lt;User&gt; findByNameLike(String name, Pageable pageable);&#125; 项目测试 测试添加 @Testpublic void testAdd() &#123; for (long i = 0; i &lt; 30; i++) &#123; User user = new User(); user.setId(i); user.setName(\"张三\" + i); user.setGender(i % 2 == 0 ? 0 : 1); userDao.save(user); Student student = new Student(); student.setId(System.currentTimeMillis() + i); student.setName(\"张三学生\" + i); student.setUserId(i); studentDao.save(student); &#125;&#125; 测试结果：数据按id取模的方式划分到了两个数据库中，同时从库同步了主库的数据 测试模糊查询+分页 @Testpublic void testFind() &#123; Pageable pageable = new PageRequest(0, 10, Sort.Direction.DESC, \"id\"); List&lt;User&gt; userList = userDao.findByNameLike(\"%张三2%\", pageable).getContent(); userList.forEach(System.out::println); Pageable pageable2 = new PageRequest(0, 10, Sort.Direction.DESC, \"userId\"); List&lt;Student&gt; studentList = studentDao.findByNameLike(\"%张三学生1%\", pageable2).getContent(); studentList.forEach(System.out::println);&#125; 测试结果：按照模糊匹配及id降序的方式输出结果 测试结果：读操作都走了从库 删除及修改请自行测试 参考链接 Mycat官网Mycat从零开始Mycat权威指南GitHub：Mycat-ServerWiki：Mycat-ServerIssues：Mycat-Servermysql中间件研究（Atlas，Cobar，TDDL）mysql中间件研究（Atlas，Cobar，TDDL，Mycat，Heisenberg，Oceanus，Vitess，OneProxy）","categories":[{"name":"数据库中间件","slug":"数据库中间件","permalink":"https://blog.mariojd.cn/categories/数据库中间件/"},{"name":"Mycat","slug":"数据库中间件/Mycat","permalink":"https://blog.mariojd.cn/categories/数据库中间件/Mycat/"}],"tags":[{"name":"Mycat","slug":"Mycat","permalink":"https://blog.mariojd.cn/tags/Mycat/"},{"name":"数据库中间件","slug":"数据库中间件","permalink":"https://blog.mariojd.cn/tags/数据库中间件/"},{"name":"实践篇","slug":"实践篇","permalink":"https://blog.mariojd.cn/tags/实践篇/"},{"name":"mysql","slug":"mysql","permalink":"https://blog.mariojd.cn/tags/mysql/"},{"name":"主从复制","slug":"主从复制","permalink":"https://blog.mariojd.cn/tags/主从复制/"},{"name":"读写分离","slug":"读写分离","permalink":"https://blog.mariojd.cn/tags/读写分离/"}]},{"title":"Mycat（配置篇）","slug":"Mycat（配置篇）","date":"un55fin55","updated":"un66fin66","comments":true,"path":"2018/03/02/Mycat（配置篇）/","link":"","permalink":"https://blog.mariojd.cn/2018/03/02/Mycat（配置篇）/","excerpt":"","text":"Mycat目录说明 bin：启动目录 conf：配置文件目录 server.xml：是Mycat服务器参数调整和用户授权的配置文件 schema.xml：是逻辑库定义和表以及分片定义的配置文件 rule.xml： 是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改需要重启MyCAT log4j.xml： 日志存放在logs/log中，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要可以调整输出级别为debug，debug级别下，会输出更多的信息，方便排查问题 autopartition-long.txt,partition-hash-int.txt,sequence_conf.properties， sequence_db_conf.properties 分片相关的id分片规则配置文件 lib：jar包目录 logs ：日志目录 tmlogs：临时日志目录 配置文件目录说明图： 3大配置文件说明server.xml&emsp;&emsp;包含了Mycat需要的系统配置信息，用户配置信息以及逻辑库配置信息，源代码中的映射类为：SystemConfig.class 添加如下配置：相当于建立了一个叫做mycat用户，对应密码为mycat，该用户管理了mycats这个逻辑库。当然了，也可以为用户添加管理多个逻辑库，以,（英文逗号）分隔开即可&lt;user name=\"mycat\"&gt; &lt;property name=\"password\"&gt;mycat&lt;/property&gt; &lt;property name=\"schemas\"&gt;mycats&lt;/property&gt;&lt;!--schemas：逻辑库名称，具体配置在scheme.xml中--&gt;&lt;/user&gt; schema.xml&emsp;&emsp;可以说是最重要的配置文件，管理着 MyCat 的逻辑库、表、分片规则、DataNode 以及 DataSource schema是实际逻辑库的配置，多个schema代表多个逻辑库 dataNode是逻辑库对应的分片，如果配置多个分片则需要添加多个dataNode即可 dataHost是实际的物理库配置，可以根据业务需要配置多主、主从等其他配置，多个dataHost代表分片对应的物理库地址，下面的writeHost、readHost代表该分片是否配置多写，主从，读写分离等高级特性 添加如下配置：水平切分，数据按Id取模均匀划分到两个数据库中&lt;schema name=\"mycats\" checkSQLschema=\"false\" sqlMaxLimit=\"100\"&gt; &lt;!-- 逻辑表配置 --&gt; &lt;table name=\"tb_user\" dataNode=\"dn1,dn2\" rule=\"mod-long\" /&gt;&lt;!--name：实际物理库的数据表名；dataNode：表对应的分片；rule：分片规则名称，具体配置在rule.xml中--&gt;&lt;/schema&gt;&lt;dataNode name=\"dn1\" dataHost=\"host1\" database=\"mycat1\" /&gt;&lt;!--name：分片名称；database：实际物理库的数据库名--&gt;&lt;dataNode name=\"dn2\" dataHost=\"host1\" database=\"mycat2\" /&gt;&lt;dataHost name=\"host1\" maxCon=\"100\" minCon=\"10\" balance=\"0\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;&lt;!--mysql心跳检测命令--&gt; &lt;writeHost host=\"hostM1\" url=\"localhost:3306\" user=\"root\" password=\"xxx\" /&gt;&lt;!--实际物理库的配置信息--&gt;&lt;/dataHost&gt; rule.xml&emsp;&emsp;定义了表拆分所涉及到的规则定义。根据业务可以灵活的对表使用不同的分片算法（目前已实现十余种不同的分片规则，对应所在源码包为：io.mycat.route.function），或者对表使用相同的算法但具体的参数不同。 添加如下配置：水平切分，数据按Id取模均匀划分到两个数据库中&lt;tableRule name=\"mod-long\"&gt; &lt;!-- 对应表的分片规则 --&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt;&lt;!-- 对应数据表要取模的字段名称 --&gt; &lt;algorithm&gt;mod-long&lt;/algorithm&gt;&lt;!-- 对应function的名称 --&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name=\"mod-long\" class=\"io.mycat.route.function.PartitionByMod\"&gt;&lt;!-- name：对应tableRule的名称；class：切分规则对应的切分类 --&gt; &lt;!-- scheme.xml中有多少个dataNode就改成多少个 --&gt; &lt;property name=\"count\"&gt;2&lt;/property&gt;&lt;/function&gt; 代码测试（SpringBoot + JPA） 准备：在对应的数据库中建好相关的表（下一篇文章将给出JPA自动建表解决方案） DROP TABLE IF EXISTS `tb_user`;CREATE TABLE `tb_user` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 添加application.yml： spring: jpa: show-sql: true hibernate: ddl-auto: update naming: strategy: org.hibernate.cfg.ImprovedNamingStrategy properties: hibernate: dialect: org.hibernate.dialect.MySQL5Dialect datasource: url: jdbc:mysql://localhost:8066/mycats?characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;rewriteBatchedStatements=true username: mycat password: mycat 添加User Entity @Entity@Table(name = \"tb_user\")@Datapublic class User &#123; @Id private Long id; private String name;&#125; 添加UserDao public interface UserDao extends JpaRepository&lt;User, Long&gt; &#123; Page&lt;User&gt; findByNameLike(String name, Pageable pageable);&#125; 测试添加@Testpublic void testAdd() &#123; for (long i = 0; i &lt; 50; i++) &#123; User user = new User(); user.setId(i); user.setName(\"ls\" + i); userDao.save(user); &#125;&#125; 测试结果：数据按id取模的方式划分到了两个数据库中 测试模糊查询+分页@Testpublic void testFind() &#123; Pageable pageable = new PageRequest(0, 10, Sort.Direction.ASC, \"id\"); List&lt;User&gt; userList = userDao.findByNameLike(\"%ls1%\", pageable).getContent(); userList.forEach(System.out::println);&#125; 测试结果：按照模糊匹配及id升序的方式输出结果 删除及修改请自行测试 参考链接 Mycat官网Mycat从零开始Mycat权威指南GitHub：Mycat-ServerWiki：Mycat-ServerIssues：Mycat-Servermysql中间件研究（Atlas，Cobar，TDDL）mysql中间件研究（Atlas，Cobar，TDDL，Mycat，Heisenberg，Oceanus，Vitess，OneProxy）","categories":[{"name":"数据库中间件","slug":"数据库中间件","permalink":"https://blog.mariojd.cn/categories/数据库中间件/"},{"name":"Mycat","slug":"数据库中间件/Mycat","permalink":"https://blog.mariojd.cn/categories/数据库中间件/Mycat/"}],"tags":[{"name":"Mycat","slug":"Mycat","permalink":"https://blog.mariojd.cn/tags/Mycat/"},{"name":"数据库中间件","slug":"数据库中间件","permalink":"https://blog.mariojd.cn/tags/数据库中间件/"},{"name":"配置篇","slug":"配置篇","permalink":"https://blog.mariojd.cn/tags/配置篇/"}]},{"title":"Mycat（入门篇）","slug":"Mycat（入门篇）","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2018/03/01/Mycat（入门篇）/","link":"","permalink":"https://blog.mariojd.cn/2018/03/01/Mycat（入门篇）/","excerpt":"","text":"Mycat是什么Mycat是一款基于阿里开源产品Cobar而研发的开源数据库分库分表中间件（基于Java语言开发）。官网所言：Mycat国内最活跃的、性能最好的开源数据库中间件！ 一个彻底开源的，面向企业应用开发的大数据库集群 支持事务、ACID、可以替代MySQL的加强版数据库 一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群 一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server 结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品 一个新颖的数据库中间件产品 Mycat关键特性 支持SQL92标准 支持MySQL、Oracle、DB2、SQL Server、PostgreSQL等DB的常见SQL语法 遵守Mysql原生协议，跨语言，跨平台，跨数据库的通用中间件代理 基于心跳的自动故障切换，支持读写分离，支持MySQL主从，以及galera cluster集群 支持Galera for MySQL集群，Percona Cluster或者MariaDB cluster 基于Nio实现，有效管理线程，解决高并发问题 支持数据的多片自动路由与聚合，支持sum,count,max等常用的聚合函数,支持跨库分页 支持单库内部任意join，支持跨库2表join，甚至基于caltlet的多表join 支持通过全局表，ER关系的分片策略，实现了高效的多表join查询 支持多租户方案 支持分布式事务（弱xa） 支持XA分布式事务（1.6.5） 支持全局序列号，解决分布式下的主键生成问题 分片规则丰富，插件化开发，易于扩展 强大的web，命令行监控 支持前端作为MySQL通用代理，后端JDBC方式支持MySQL、PostgreSQL、Oracle、DB2、SQLServer、MongoDB、巨杉 支持密码加密 支持服务降级 支持IP白名单 支持SQL黑名单、sql注入攻击拦截 支持prepare预编译指令（1.6） 支持非堆内存(Direct Memory)聚合计算（1.6） 支持PostgreSQL的native协议（1.6） 支持mysql和oracle存储过程，out参数、多结果集返回（1.6） 支持zookeeper协调主从切换、zk序列、配置zk化（1.6） 支持库内分表（1.6） 集群基于ZooKeeper管理，在线升级，扩容，智能优化，大数据处理（2.0开发版） 安装与使用 下载（目前最新发行版是1.6.5）：http://dl.mycat.io/ 安装：解压即可 配置：Mycat是基于Java开发的，确保安装好了Java环境，可命令行输入：java -version 进行测试。Linux下还需配置Mycat的解压目录：vim /etc/profile，配置完成后使用：source /etc/profile： export JAVA_HOME=xxxexport MYCAT_HOME=xxx 运行（Linux）： ./mycat start 启动 ./mycat stop 停止 ./mycat console 前台运行 ./mycat install 添加到系统自动启动（暂未实现） ./mycat remove 取消随系统自动启动（暂未实现） ./mycat restart 重启服务 ./mycat pause 暂停 ./mycat status 查看启动状态 运行（Windows）：双击bin/tartup_nowrap.bat，如果出现闪退，可在cmd命令行运行，并查看出错原因 内存配置：启动前，一般需要修改JVM配置参数，打开conf/wrapper.conf文件，可根据本机配置情况修改为512M或其它值 # Java Additional Parameters#wrapper.java.additional.1=wrapper.java.additional.1=-DMYCAT_HOME=.wrapper.java.additional.2=-serverwrapper.java.additional.3=-XX:MaxPermSize=64Mwrapper.java.additional.4=-XX:+AggressiveOptswrapper.java.additional.5=-XX:MaxDirectMemorySize=2Gwrapper.java.additional.6=-Dcom.sun.management.jmxremotewrapper.java.additional.7=-Dcom.sun.management.jmxremote.port=1984wrapper.java.additional.8=-Dcom.sun.management.jmxremote.authenticate=falsewrapper.java.additional.9=-Dcom.sun.management.jmxremote.ssl=falsewrapper.java.additional.10=-Xmx4Gwrapper.java.additional.11=-Xms1G 连接测试： 测试mycat与测试mysql完全一致，mysql怎么连接，mycat就怎么连接 命令行：mysql -uroot -proot -P8066 -h127.0.0.1（其中，user和password可在conf/server.xml配置查找，8066是默认的服务端口，也可以在conf/server.xml中配置修改） 客户端：1.3和1.4版本目前部分工具无法连接，会提示database not selected，建议使用高版本的Mycat，1.5版本已经修复了部分客户端工具的连接 常见分库分表产品对比 分库分表产品 MyCat Sharding-JDBC Cobar Cobar-client TDDL 分库 有 有 有 有 未开源 分表 有 有 无 无 未开源 中间层 是 否 是 否 否 ORM支持 任意 任意 任意 仅MyBatis 任意 数据库支持 任意 任意 仅MySQL 任意 任意 社区情况 活跃 活跃 停更 未知 未知 相关链接 Mycat官网Mycat从零开始Mycat权威指南GitHub：Mycat-ServerWiki：Mycat-ServerIssues：Mycat-Servermysql中间件研究（Atlas，Cobar，TDDL）mysql中间件研究（Atlas，Cobar，TDDL，Mycat，Heisenberg，Oceanus，Vitess，OneProxy）","categories":[{"name":"数据库中间件","slug":"数据库中间件","permalink":"https://blog.mariojd.cn/categories/数据库中间件/"},{"name":"Mycat","slug":"数据库中间件/Mycat","permalink":"https://blog.mariojd.cn/categories/数据库中间件/Mycat/"}],"tags":[{"name":"Mycat","slug":"Mycat","permalink":"https://blog.mariojd.cn/tags/Mycat/"},{"name":"数据库中间件","slug":"数据库中间件","permalink":"https://blog.mariojd.cn/tags/数据库中间件/"},{"name":"入门篇","slug":"入门篇","permalink":"https://blog.mariojd.cn/tags/入门篇/"}]},{"title":"面向切面的Spring - 《Spring实战》第4章（笔记）","slug":"面向切面的Spring - 《Spring实战》第4章（笔记）","date":"un00fin00","updated":"un66fin66","comments":true,"path":"2018/02/11/面向切面的Spring - 《Spring实战》第4章（笔记）/","link":"","permalink":"https://blog.mariojd.cn/2018/02/11/面向切面的Spring - 《Spring实战》第4章（笔记）/","excerpt":"","text":"写在前面&emsp;&emsp;本文是博主在看完面向切面的Spring（《Spring实战》第4章）后的一些实践笔记。&emsp;&emsp;为什么要用AOP呢？作者在书中也明确提到了，使用AOP，可以让代码逻辑更多的去关注自己本身的业务，而不用混杂和关注一些其它的东西。包括：安全，缓存，事务，日志等等。 名词概念 通知（Advice） &emsp;&emsp;定义了切面做什么和什么时候去做。简单点来说，就是AOP执行时会调用的方法，通知除了定义切面要完成的工作(What)，还会定位什么时候(When)去履行这项工作，是在方法调用前，还是调用之后，还是前后都是，还是抛出异常时 在切面定义中，一共有以下五种通知类型 类型 作用 Before 某方法调用之前发出通知 After 某方法完成之后发出通知，不考虑方法运行的结果 AfterReturning 将通知放置在被通知的方法成功执行之后 AfterThrowing 将通知放置在被通知的方法抛出异常之后 Around 通知包裹在被通知的方法的周围，在方法调用之前和之后发出（环绕通知 = 前置 + 目标方法执行 + 后置通知） 切点，也叫切入点（Pointcut） &emsp;&emsp;上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有十几个连接点了对吧，但是你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法 连接点，也叫参加点（JoinPoint） &emsp;&emsp;连接点是切面在应用程序执行过程中插入的地方，可能是方法调用（前、后）的时候，也可能是异常抛出的时候。连接点如果可以说是切点的全集，那么切点就是连接点的子集 切面（Aspect） &emsp;&emsp;切面其实就是通知和切点的结合。通知说明了干什么和什么时候干（通过方法上使用@Before、@After等就能知道），则切点说明了在哪干（指定到底是哪个方法），这就组成了一个完整的切面定义 Spring对AOP的支持 Spring建议在Java中编写AOP，虽然用XML也可以实现 Spring通过使用代理类，在运行阶段将切面编织进bean中 Spring只支持方法级别的连接点，不像AspectJ还可以通过构造器或属性注入 切点表达式&emsp;&emsp;切点表达式算是一些比较概念性的知识，下面截了两个图供大家参考参考 &emsp;&emsp;看得头晕了吧，不过好在只有execution()是用来执行匹配的，剩下的都是为了限制或定制连接点要匹配的位置&emsp;&emsp;以下是execution()定义的格式（其中，带?号的为可选，否则必须给出） : execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) &emsp;&emsp;还是举个真实栗子模仿一下吧 execution(* com.example.aspectj.UserDao.updateName(..)) execution：用于定义什么方法执行时会被触发，这里是指com.example.aspectj包下的UserDao接口中的updateName方法执行时触发 * ：忽略方法返回值类型 (..) ：匹配任意参数 实战测试（SpringBoot + JPA） Create Entity @Table(name = \"tb_user\")@Entity@Datapublic class User &#123; @Id @GeneratedValue private Integer id; private String name;&#125; Create Dao public interface UserDao extends JpaRepository&lt;User, Integer&gt; &#123; @Modifying @Transactional @Query(\"update User u set u.name = ?1 where u.id = ?2\") int updateName(String name, int id);&#125; Create Service @Servicepublic class UserService &#123; @Resource private UserDao userDao; @Transactional public void save(User user) &#123; userDao.save(user); &#125; public void update(String name, int id) &#123; userDao.updateName(name, id); &#125;&#125; 第一种风格的切面 Create Aspect（使用了@Before、@After、@AfterReturning和@AfterThrowing这四个注解） @Aspectpublic class UserAspectjOne &#123; @Resource private UserService userService; @Before(\"execution(* com.example.aspectj.UserDao.updateName(..))\") public void before() &#123; System.out.println(\"1.------------before()\"); &#125; @After(\"execution(* com.example.aspectj.UserDao.updateName(..))\") public void after() &#123; System.out.println(\"1.------------after()\"); &#125; @AfterReturning(\"execution(* com.example.aspectj.UserDao.updateName(..))\") public void afterReturning() &#123; System.out.println(\"1.------------afterReturning()\"); User user = new User(); user.setName(\"afterReturning1\"); userService.save(user); &#125; @AfterThrowing(\"execution(* com.example.aspectj.UserDao.updateName(..))\") public void afterThrowing() &#123; System.out.println(\"1.------------afterThrowing()\"); User user = new User(); user.setName(\"afterThrowing1\"); userService.save(user); &#125;&#125; Create Configuration @Configuration// @EnableAspectJAutoProxy //实测可以不添加该注解，因为SpringBoot中已经默认开启了AOP功能public class AspectjConfiguration &#123; @Bean public UserAspectjOne userAspectjOne() &#123; return new UserAspectjOne(); &#125;&#125; Test updateName() with UserAspectjOne 6.1 先往数据库里添加一条数据@Test public void testAdd() &#123; User user = new User(); user.setName(\"jared\"); userDao.save(user); &#125; ![添加User][4] - 6.2 测试正常执行updateName() @Test public void testUpdateName() &#123; userService.update(\"jared qiu\", 1); &#125; - 6.3.1 打印结果 ![输出结果][5] - 6.3.2 数据库结果 ![数据库结果][6] - 6.4 测试非正常执行updateName()，只需要把UserDao类中updateName()上的@Modifying或者@Transactional注解去掉即可 @Test public void testUpdateName() &#123; userService.update(\"error jared qiu\", 1); &#125; - 6.5.1 打印结果 ![输出结果][7] - 6.5.2 数据库结果 ![数据库结果][8] 第二种风格的切面 Create Aspect（依旧使用了@Before、@After、@AfterReturning和@AfterThrowing这四个注解，但新增了@Pointcut注解，把切面的定义抽离了出来进行统一） @Aspectpublic class UserAspectjTwo &#123; @Resource private UserService userService; @Pointcut(\"execution(* com.example.aspectj.UserDao.updateName(..))\") public void pointcut() &#123; &#125; @Before(\"pointcut()\") public void before() &#123; System.out.println(\"2.------------before()\"); &#125; @After(\"pointcut()\") public void after() &#123; System.out.println(\"2.------------after()\"); &#125; @AfterReturning(\"pointcut()\") public void afterReturning() &#123; System.out.println(\"2.------------afterReturning()\"); User user = new User(); user.setName(\"afterReturning2\"); userService.save(user); &#125; @AfterThrowing(\"pointcut()\") public void afterThrowing() &#123; System.out.println(\"2.------------afterThrowing()\"); User user = new User(); user.setName(\"afterThrowing2\"); userService.save(user); &#125;&#125; Create Configuration @Configurationpublic class AspectjConfiguration &#123; @Bean public UserAspectjTwo userAspectjTwo() &#123; return new UserAspectjTwo(); &#125;&#125; Test updateName() with UserAspectjTwo 6.1 先往数据库里添加一条数据@Test public void testAdd() &#123; User user = new User(); user.setName(\"jared\"); userDao.save(user); &#125; ![添加User][9] - 6.2 测试正常执行updateName() @Test public void testUpdateName() &#123; userService.update(\"jared qiu\", 1); &#125; - 6.3.1 打印结果 ![输出结果][10] - 6.3.2 数据库结果 ![数据库结果][11] - 6.4 测试非正常执行updateName()，只需要把UserDao类中updateName()上的@Modifying或者@Transactional注解去掉即可 @Test public void testUpdateName() &#123; userService.update(\"error jared qiu\", 1); &#125; - 6.5.1 打印结果 ![输出结果][12] - 6.5.2 数据库结果 ![数据库结果][13] 第三种风格的切面 Create Aspect（使用了@Around这个环绕注解） @Aspectpublic class UserAspectjThree &#123; @Resource private UserService userService; /** * 方法的返回值类型须与切面所在方法的返回值类型保持一致 */ @Around(\"execution(* com.example.aspectj.UserDao.updateName(..))\") public int around(ProceedingJoinPoint joinPoint) &#123; try &#123; System.out.println(\"3.------------before()\"); System.out.println(\"3.------------after()\"); joinPoint.proceed();//用于启动目标方法执行（必须） System.out.println(\"3.------------afterReturning()\"); User user = new User(); user.setName(\"afterReturning3\"); userService.save(user); &#125; catch (Throwable e) &#123; System.out.println(\"3.------------afterThrowing()\"); User user = new User(); user.setName(\"afterThrowing3\"); userService.save(user); &#125; return 1; &#125;&#125; Create Configuration @Configurationpublic class AspectjConfiguration &#123; @Bean public UserAspectjThree userAspectjThree() &#123; return new UserAspectjThree(); &#125;&#125; Test updateName() with UserAspectjThree 6.1 先往数据库里添加一条数据@Test public void testAdd() &#123; User user = new User(); user.setName(\"jared\"); userDao.save(user); &#125; ![添加User][14] - 6.2 测试正常执行updateName() @Test public void testUpdateName() &#123; userService.update(\"jared qiu\", 1); &#125; - 6.3.1 打印结果 ![输出结果][15] - 6.3.2 数据库结果 ![数据库结果][16] - 6.4 测试非正常执行updateName()，只需要把UserDao类中updateName()上的@Modifying或者@Transactional注解去掉即可 @Test public void testUpdateName() &#123; userService.update(\"error jared qiu\", 1); &#125; - 6.5.1 打印结果 ![输出结果][17] - 6.5.2 数据库结果 ![数据库结果][18] 第四种风格的切面 Create Aspect（依旧使用了@Around这个环绕注解，但加入了@Pointcut注解和传递了参数） @Aspectpublic class UserAspectjFour &#123; @Resource private UserService userService; @Pointcut(\"execution(* com.example.aspectj.UserDao.updateName(String,*)) &amp;&amp; args(name,*)\") public void pointcut(String name) &#123; &#125; @Around(value = \"pointcut(name)\", argNames = \"joinPoint,name\") public int around(ProceedingJoinPoint joinPoint, String name) &#123; try &#123; System.out.println(\"4.------------before()\"); System.out.println(\"4.------------after()\"); Object proceed = joinPoint.proceed(); System.out.println(proceed); System.out.println(\"4.------------afterReturning()\"); User user = new User(); user.setName(\"afterReturning4\" + name); userService.save(user); &#125; catch (Throwable e) &#123; System.out.println(\"4.------------afterThrowing()\"); User user = new User(); user.setName(\"afterThrowing4\" + name); userService.save(user); &#125; return 1; &#125;&#125; Create Configuration @Configurationpublic class AspectjConfiguration &#123; @Bean public UserAspectjFour userAspectjFour() &#123; return new UserAspectjFour(); &#125;&#125; Test updateName() with UserAspectjFour 6.1 先往数据库里添加一条数据@Test public void testAdd() &#123; User user = new User(); user.setName(\"jared\"); userDao.save(user); &#125; ![添加User][19] - 6.2 测试正常执行updateName() @Test public void testUpdateName() &#123; userService.update(\"jared qiu\", 1); &#125; - 6.3.1 打印结果 ![输出结果][20] - 6.3.2 数据库结果 ![数据库结果][21] - 6.4 测试非正常执行updateName()，只需要把UserDao类中updateName()上的@Modifying或者@Transactional注解去掉即可 @Test public void testUpdateName() &#123; userService.update(\"error jared qiu\", 1); &#125; - 6.5.1 打印结果 ![输出结果][22] - 6.5.2 数据库结果 ![数据库结果][23] 扩展@EnableAspectJAutoProxy 表示开启AOP代理自动配置，如果配@EnableAspectJAutoProxy表示使用cglib进行代理对象的生成；设置@EnableAspectJAutoProxy(exposeProxy=true)表示通过aop框架暴露该代理对象，使得aopContext能够直接访问 从@EnableAspectJAutoProxy的定义可以看出，它引入AspectJAutoProxyRegister.class对象，该对象是基于注解@EnableAspectJAutoProxy注册了一个AnnotationAwareAspectJAutoProxyCreator，通过调用AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry)，注册了一个aop代理对象生成器 参考链接 AspectJSpring AOP系列Spring AOP中JoinPoint的表达式定义描述","categories":[{"name":"Spring","slug":"Spring","permalink":"https://blog.mariojd.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.mariojd.cn/tags/Spring/"},{"name":"《Spring in action》","slug":"《Spring-in-action》","permalink":"https://blog.mariojd.cn/tags/《Spring-in-action》/"},{"name":"AcpectJ","slug":"AcpectJ","permalink":"https://blog.mariojd.cn/tags/AcpectJ/"},{"name":"Aop","slug":"Aop","permalink":"https://blog.mariojd.cn/tags/Aop/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.mariojd.cn/tags/读书笔记/"}]},{"title":"BIO、伪异步IO、NIO和AIO学习","slug":"BIO、伪异步IO、NIO和AIO的学习","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2018/02/10/BIO、伪异步IO、NIO和AIO的学习/","link":"","permalink":"https://blog.mariojd.cn/2018/02/10/BIO、伪异步IO、NIO和AIO的学习/","excerpt":"","text":"BIO（同步阻塞，一请求一应答） 伪异步IO（同步阻塞，线程池） NIO （同步非阻塞，多路复用） AIO（异步非阻塞，异步通道） Client数：线程数 1：1 N：M（N &gt;= M） M：1 N：0 API难度 简单 简单 复杂 较复杂 调试难度 简单 简单 复杂 较复杂 可靠性 最差 差 高 高 吞吐量 最低 低 高 高","categories":[{"name":"IO","slug":"IO","permalink":"https://blog.mariojd.cn/categories/IO/"},{"name":"Java","slug":"IO/Java","permalink":"https://blog.mariojd.cn/categories/IO/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://blog.mariojd.cn/tags/IO/"},{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/tags/Java/"},{"name":"Study","slug":"Study","permalink":"https://blog.mariojd.cn/tags/Study/"}]},{"title":"IDEA快捷键拆解系列（一）","slug":"IDEA快捷键拆解系列（一）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2018/02/10/IDEA快捷键拆解系列（一）/","link":"","permalink":"https://blog.mariojd.cn/2018/02/10/IDEA快捷键拆解系列（一）/","excerpt":"","text":"&emsp;&emsp;这是IDEA快捷键拆解系列的第一篇。 &emsp;&emsp;本系列从最顶部的导航栏，以及周围、中间区域的快捷键提示开始讲起。在此之前，请记住非常重要的一个快捷键： Alt + 下划线那个符号。举个栗子，左上角有++F++ile这么个导航项，所以对应的快捷键就是：Alt + F，其它任意有下划线的都是同样的操作，包括导航项展开的任意子项，只要选项中带有某一下划线的字符，我们就可以通过这种形式来进行快速定位。除此之外，我们还可以通过 ↑和 ↓来上下移动，然后通过Enter键来选择相应的操作。 &emsp;&emsp;在IDEA中，中间区域的快捷键是最明显的，所以应该也是最重要的，以下是对每一项的详细拆解。 中间提示区域快捷键 作用 快捷键 拆解 Search Everywhere Double Shift 全局搜索，按两下Shift弹出此界面，再按两下Shift可以搜索非当前项目的文件（如依赖的Jar包），右上角还可以设置展示的类型 Project View Alt + 1 Project面板的展开与折叠切换，此外，还可用于代码区快速跳转至项目区（返回使用ESC） Go to File Ctrl + Shift + N 搜素文件，按Ctrl+Shift+N弹出此界面，再按一下Ctrl+Shift+N可以搜索非当前项目的文件，右上角还可以设置搜索的文件类型 Recent Files Ctrl + E 按Ctrl+E可以弹出记录了最近操作的面板，一般左边对应的是整个IDEA界面周边的各个功能选项，右边则是你最近操作的文件列表。左右方向键用于左右跳转，上下方向键用于切换，Enter用于打开选择 Navigation Bar Alt + Home 跳转到项目的导航栏，也可以通过这种方式进行文件切换和打开 周边工具窗口快捷键 位置（面板） 快捷键 拆解 左边（Project） Alt + 1 快速展开（折叠）项目窗口 左边（Structure） Alt + 7 快速展开（折叠）结构窗口，一般用于查看类结构 左边（Favorites） Alt + 2 快速展开（折叠）书签窗口，一般用于查看书签 下边（Run） Alt + 4 项目正常运行的时候会有此窗口 下边（Debug） Alt + 5 项目Debug运行的时候会有此窗口 下边（TODO） Alt + 6 快速展开（折叠）TODO窗口，一般用于查看待办事项 下边（Version Control） Alt + 9 快速展开（折叠）版本控制窗口 下边（Terminal） Alt + 12 快速展开（折叠）终端窗口","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"快捷键","slug":"编辑器/快捷键","permalink":"https://blog.mariojd.cn/categories/编辑器/快捷键/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://blog.mariojd.cn/tags/JetBrains/"}]},{"title":"Docker（二）","slug":"Docker（二）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2018/02/10/Docker（二）/","link":"","permalink":"https://blog.mariojd.cn/2018/02/10/Docker（二）/","excerpt":"","text":"1、Dockerfile FROM 。FROM指令必须指定且需要在Dockerfile其他指令的前面，指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。后续的指令都依赖于该指令指定的image。当在同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令。 FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt;FROM &lt;image&gt;@&lt;digest&gt; MAINTAINER。用于指定维护者的信息 ```* RUN。支持两种格式： RUN 或RUN [“executable”, “param1”, “param2”]* CMD。主要目的是为执行容器提供默认值。每个Dockerfile只有一个CMD命令，如果指定了多个CMD命令，那么只有一条会被执行，如果启动容器的时候指定了运行的命令，则会覆盖掉CMD指定的命令。 CMD [“executable”,”param1”,”param2”] (推荐使用)CMD [“param1”,”param2”] (为ENTRYPOINT指令提供预设参数)CMD command param1 param2 (在shell中执行)* LABEL。为镜像添加元数据```LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ... EXPOSE。为Docker容器设置对外的端口号。在启动时，可以使用-p选项或者-P选项。 [...]```* ENV。指定环境变量，会被后续RUN指令使用，并在容器启动后，可以通过docker inspect查看这个环境变量，也可以通过docker run --env &lt;key&gt;=&lt;value&gt; 来修改环境变量。 ENV ENV = …* ADD。从src目录复制文件到容器的dest。其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL，还可以是一个压缩包。* COPY。复制本地端的src到容器的dest。和ADD指令类似，COPY不支持URL和压缩包。* ENTRYPOINT。指定Docker容器启动时执行的命令，可以多次设置，但是只有最后一个有效。* VOLUME。使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。``` VOLUME [&quot;/data&quot;] USER。设置启动容器的用户，默认是root用户。 用户名 ```* WORKDIR。切换目录指令，类似于cd命令，对RUN、CMD、ENTRYPOINT生效。``` WORKDIR /path/to/workdir ARG。定义一个变量。 [* ONBUILD。指定当建立的镜像作为其他镜像的基础时，所执行的命令。``` ONBUILD [INSTRUCTION] 2、使用Dockerfile构建Docker镜像 在项目jar包所在目录创建文件，命名为Dockerfile from java:8 # 基于哪个镜像volume /tmp # 将本地文件夹挂载到当前容器# 添加文件到容器add xxx.jar app.jarrun bash -c &apos;touch /app.jar&apos;expose 12345 # 开放12345端口entrypoint [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] # 配置容器启动后执行的命令 构建docker镜像，执行 docker build -t hello/test1 . # 格式：docker build -t 标签名称 Dockerfile的相对位置（.表示当前位置） 启动镜像，查看 docker run -d -p 8080:12345 hello/test1 3、使用Maven插件构建Docker镜像 //TODO 4、关于Docker Compose（工具）&emsp;&emsp;编写Dockerfile 可以让用户管理一个单独的容器，那么如果要管理多个容器呢，例如：我们需要管理一个Web应用的同时还要加上其后端的数据库服务容器呢？而Docker Compose就是这样的一个工具。&emsp;&emsp;官网对Compose的定义是：Compose 是一个用于定义和运行多容器的Docker应用的工具。使用Compose，你可以在一个配置文件（yaml格式）中配置你的应用的服务，然后使用一个命令，即可创建并启动配置中引用的所有服务。 安装Compose（官方文档：https://docs.docker.com/compose/install/ ） 下载docker-compose ，并放到/usr/local/bin/ curl -L https://github.com/docker/compose/releases/download/1.8.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 为Docker Compose脚本添加执行权限 chmod +x /usr/local/bin/docker-compose 测试命令，如果有版本信息输出则说明Compose已经成功安装 docker-compose --version docker-compose.yml常用命令（官方文档：https://docs.docker.com/compose/compose-file/ ） image 指定镜像名称或者镜像id，如果该镜像在本地不存在，Compose会尝试pull下来。示例：java```* build 指定Dockerfile文件的路径。可以是一个路径，示例：```build: ./dir 也可以是一个对象，用以指定Dockerfile和参数，示例：build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 command 覆盖容器启动后默认执行的命令。示例： bundle exec thin -p 3000```也可以是一个list，类似于Dockerfile总的CMD指令，格式如下：```command: [bundle, exec, thin, -p, 3000] links 链接到其他服务中的容器。可以指定服务名称和链接的别名使用SERVICE:ALIAS 的形式，或者只指定服务名称，示例： web: links: - db - db:database - redis external_links 表示链接到docker-compose.yml外部的容器，甚至并非Compose管理的容器，特别是对于那些提供共享容器或共同服务。格式跟links类似，示例： external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql ports 暴露端口信息。使用宿主端口:容器端口的格式，或者仅仅指定容器的端口（此时宿主机将会随机指定端口），类似于docker run -p ，示例： ports: - &quot;3000&quot; - &quot;3000-3005&quot; - &quot;8000:8000&quot; - &quot;9090-9091:8080-8081&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot; - &quot;127.0.0.1:5000-5010:5000-5010&quot; expose 暴露端口，只将端口暴露给连接的服务，而不暴露给宿主机，示例： expose: - &quot;3000&quot; - &quot;8000&quot; volumes 卷挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。示例： volumes: # Just specify a path and let the Engine create a volume - /var/lib/mysql # Specify an absolute path mapping - /opt/data:/var/lib/mysql # Path on the host, relative to the Compose file - ./cache:/tmp/cache # User-relative path - ~/configs:/etc/configs/:ro # Named volume - datavolume:/var/lib/mysql volumes_from 从另一个服务或者容器挂载卷。可以指定只读或者可读写，如果访问模式没有指定，则默认是可读写。示例： volumes_from: - service_name - service_name:ro - container:container_name - container:container_name:rw environment 设置环境变量。可以使用数组或者字典两种方式。只有一个key的环境变量可以在运行Compose的机器上找到对应的值，这有助于加密的或者特殊主机的值。示例： environment: RACK_ENV: development SHOW: &apos;true&apos; SESSION_SECRET: environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET env_file从文件中获取环境变量，可以为单独的文件路径或列表。如果通过 docker-compose -f FILE 指定了模板文件，则 env_file 中路径会基于模板文件路径。如果有变量名称与 environment 指令冲突，则以envirment 为准。示例： env_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env extends 继承另一个服务，基于已有的服务进行扩展。 net 设置网络模式。示例： net: &quot;bridge&quot;net: &quot;host&quot;net: &quot;none&quot;net: &quot;container:[service name or container name/id]&quot; dns 配置dns服务器。可以是一个值，也可以是一个列表。示例： dns: 8.8.8.8dns: - 8.8.8.8 - 9.9.9.9dns_search 配置DNS的搜索域，可以是一个值，也可以是一个列表，示例：dns_search: example.comdns_search: - dc1.example.com - dc2.example.com docker-compose常用命令（官方文档：https://docs.docker.com/compose/overview/ ） //TODO 参考文档 Docker —— 从入门到实践：http://udn.yyuap.com/doc/docker_practice/index.html使用Spring Cloud与Docker实战微服务：http://book.itmuch.com/简述 Docker：http://www.importnew.com/24658.htmlDocker 镜像、容器、仓库的概念：http://blog.csdn.net/SmalOSnail/article/details/53117496Docker实践 - 安装Docker并在容器里运行tomcat：http://blog.csdn.net/massivestars/article/details/54352484Docker官方文档：https://docs.docker.com/engine/understanding-docker/Docker中文文档：http://git.oschina.net/widuu/chinese_dockerDocker Hub：https://hub.docker.com/Dockerfile文档：https://docs.docker.com/engine/reference/builder/#dockerfile-referenceDockerfile最佳实践：https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#build-cache","categories":[{"name":"docker","slug":"docker","permalink":"https://blog.mariojd.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.mariojd.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"https://blog.mariojd.cn/tags/容器/"}]},{"title":"Docker（一）","slug":"Docker（一）","date":"un55fin55","updated":"un66fin66","comments":true,"path":"2018/02/09/Docker（一）/","link":"","permalink":"https://blog.mariojd.cn/2018/02/09/Docker（一）/","excerpt":"","text":"1、Docker简述&emsp;&emsp;Docker是基于Golang语言编写的一种轻量级的容器技术。自2013年问世以来，不管是在云服务、微服务还是DevOps企业中，都有越来越多的公司使用Docker 来作为基础设施自动化的工具 。Docker简单、轻量且高效，使用起来比较容易上手，所以很适合一些迭代开发较快的互联网公司，特别是当系统架构庞大或者是业务复杂到连开发和部署都比较困难的时候，使用Docker更是一个明智的选择。 2、什么是Docker Docker是开源的应用容器引擎，容器即服务（docker containers as a service）； Docker可以让你将所有的应用软件打包成软件开发的标准化单元； Docker容器将软件以及它运行安装所需的一切文件（代码、运行时、系统工具、系统库）打包到一起，这就保证了不管在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，“一次编写，到处运行（write once, run anywhere）”，而 Docker 是 “一次构建，到处运行（build once，run anywhere）”。 Docker 是为开发人员和系统管理员用于构建、发布、并运行分布式应用程序的开放式平台。该平台由 Docker 引擎（一个便携、轻巧的运行时和打包工具） 和 Docker Hub （一个共享应用程序和自动化工作流的云服务）等组成。 3、相关概念 注册服务器（Registry）&emsp;&emsp;注册服务器是存放仓库的地方，其上往往存放着多个仓库 仓库（Repository）&emsp;&emsp;类似代码仓库，是Docker集中存放镜像文件的场所，根据存储的镜像公开分享与否，Docker仓库又分为公开仓库（public）和私有仓库（private）两种形式。目前，最大的公开仓库是Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括Docker Pool、网易蜂巢等，可以提供稳定的国内访问 镜像（Image）&emsp;&emsp;Docker镜像（Image）类似于虚拟机的镜像，可以理解为一个面向Docker引擎的只读模板，里面包含了文件系统。例如：一个镜像可以完全包含了Ubuntu操作系统环境，可以把它称作一个Ubuntu镜像。镜像也可以安装了Apache应用程序（或其他软件），可以把它称为一个Apache镜像。镜像是创建Docker容器的基础，用户可以从网上下载一个已经做好的应用镜像，并通过命令直接使用。总之，应用（容器）运行是需要环境的，而镜像就是来提供这种环境的 容器（Container）&emsp;&emsp;Docker容器（Container）类似于一个轻量级的沙箱子（因为Docker是基于Linux内核的虚拟技术，所以消耗资源十分少），Docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而容器间都是相互隔离、互不可见的。可以把每个容器看作一个简易版的Linux系统环境（包括了root用户权限、进程空间、用户空间和网络空间），以及与运行在其中的应用程序打包而成的应用盒子 4、Docker 的优点 轻量：所有容器在一台机器上共享同一个操作系统内核，这样他们立即开始，并更有效地利用内存。Image（也就是镜像） 是从分层文件系统的构建，这样他们能够共享公共文件，使得磁盘使用率和 Image 的下载更加高效； 开放：Docker 容器是基于开发的标准，允许容器运行在主流的 Linux 发布版和 Microsoft 操作系统作为所有的基础设施； 安全：容器使得应用程序之间彼此隔离，类似虚拟机技术的资源隔离，但性能却远远高于虚拟机技术，作为基础架构的同时也为应用程序提供了额外的保护层； 敏捷开发：Docker 让开发人员可以自由定义环境，创建和部署的应用程序更快、更容易，IT 运维人员快速应对变化也更加灵活性； 高可控性：Docker 使得开发人员保存从基础设施到应用的代码，帮助 IT 运维人管理拥有标准的、安全的、可扩展的操作环境； 高可移植性：Docker 允许自由选择，可以是从笔记本电脑到一个团队，从私人基础设施到公共云提供商。 5、Docker安装 sudo yum install docker（centos） sudo apt-get install docker.io （ubuntu）systemctl start docker sudo wget -qO- https://get.docker.com/ | sh **or** curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -sudo usermod -aG docker &lt;username&gt;systemctl start docker 6、Docker常用命令及参数 命令 解释 docker images 列出本地的所有镜像 docker search 默认在Docker Hub中搜索镜像 docker pull 拉取Docker镜像 docker rmi or 删除Docker镜像。加参数-f表示强制删除 docker run 启动Docker镜像。参数有，-d：后台运行容器；-P：随机端口映射；-p：指定端口映射 docker ps 列表所有运行中的Docker容器。参数有，-a：列表所有容器；-f：过滤；-q 只列出容器的id docker version 查看Docker版本信息 docker info 查看Docker系统信息，例如：CPU、内存、容器个数等 docker kill 杀死容器 docker start / stop / restart 容器id 启动、停止、重启指定容器 docker build -t 标签名称 目录 构建Docker镜像，-t 表示指定一个标签 docker tag 为镜像打标签 7、项目容器化（以Tomcat为例） 拉取镜像：docker pull tomcat 通过镜像跑起一个容器：docker run -d -p 8081:8080 tomcat，可以通过命令传送我们的项目文件到容器里运行：docker cp；不过还有更简单的通过挂载目录的方式来运行项目：docker run –privileged=true -v ~/www:/usr/local/tomcat/webapps -d -p 8081:8080 tomcat，其中–privileged=true表示授予docker挂载的权限 拷贝war包到挂载目录 参考文档 Docker，从入门到实践：http://udn.yyuap.com/doc/docker_practice/index.html使用Spring Cloud与Docker实战微服务：http://book.itmuch.com/简述 Docker：http://www.importnew.com/24658.htmlDocker 镜像、容器、仓库的概念：http://blog.csdn.net/SmalOSnail/article/details/53117496Docker实践 - 安装Docker并在容器里运行tomcat：http://blog.csdn.net/massivestars/article/details/54352484Docker官方文档：https://docs.docker.com/engine/understanding-docker/Docker中文文档：http://git.oschina.net/widuu/chinese_dockerDocker Hub：https://hub.docker.com/Dockerfile文档：https://docs.docker.com/engine/reference/builder/#dockerfile-referenceDockerfile最佳实践：https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#build-cache","categories":[{"name":"docker","slug":"docker","permalink":"https://blog.mariojd.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.mariojd.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"https://blog.mariojd.cn/tags/容器/"},{"name":"入门","slug":"入门","permalink":"https://blog.mariojd.cn/tags/入门/"}]},{"title":"IDEA快捷键拆解系列（前言）","slug":"IDEA快捷键拆解系列（前言）","date":"un55fin55","updated":"un66fin66","comments":true,"path":"2018/02/09/IDEA快捷键拆解系列（前言）/","link":"","permalink":"https://blog.mariojd.cn/2018/02/09/IDEA快捷键拆解系列（前言）/","excerpt":"","text":"&emsp;&emsp;在学校那会，前两年入门写代码用的IDE都是Eclipse，后来也不知道从哪里看到了IDEA，就这样开始慢慢入坑了。博主不是来吐槽的，但博主现在确实对Eclipse不太感冒了，只记得代码提示似乎不太智能，默认的主题是白色，更换的主题又总是不太搭配。就这样，使用了几个学期的Eclipse，最后博主对Eclipse快捷键也还不是很熟悉，感觉就是不（hao）太（bu）棒（shuang）。 &emsp;&emsp;接触IDEA到现在有一年多了。刚跳坑那会，博主就觉得这款编辑器打开蛮快的，智能提示很棒，但对编辑器的基本结构、快捷键等等都不太熟悉，现在出来实（gong）习（zuo），才慢慢重视起快捷键的培养。正所谓，花点时间去了解和学习好的东西都是非常值得的，特别是对于程序员这种职业来说，提高速度就意味着提高了生（zao）产（xia）率（ban）；提高了生产率，就有了更多的时间去展开新的学习。熟练使用快捷键的好处不只是节省时间，更是将大脑从重复机械的劳动中解放出来，让时间能够关注到更为重要的部分。日常生活中，大到操作系统，小到浏览器，都有各种各样的快捷键，这也是博主为什么会写这么一个快捷键系列的原因。 &emsp;&emsp;JetBrains真是一家很棒的公司，官网的Title上写着：Developer Tools for Professionals and Teams。在产品一栏中，有很多优秀的开发者工具。博主希望通过这一系列的教程，能够让大家快速的上手IDEA快捷键，那么以后我们就可以非常轻松的使用像PyCharm、WebStrom、GoLand等等这一系列其他语言开发者喜欢的编辑器。正因为它们都出自同一家公司，因此很多快捷键都是一通百通，特别好上手。 &emsp;&emsp;如果说还有什么需要犹豫，那么产品付费可能是阻挡代码狗进步的唯一理由了。不过好在JetBrains提供了免费的社区版，相较与旗舰版，虽然少了一些功能，但对于学生或者入门级开发者而言，社区版的这些功能基本是够用的，如果确实想使用旗舰版，大天朝当然有很多的鬼点子，可以自己去了解一下，有能力的还是支持一下正版吧。 &emsp;&emsp;如果是第一次安装IDEA，博主强烈建议，先下载JetBrains的Toolbox，以后我们通过这款工具来下载、安装甚至升级编辑器都会非常方便。 &emsp;&emsp;不积跬步，无以至千里。要想成为优秀程序员，光有一腔热血是远远不够的，要持之以恒，要坚持不懈的学习。废话不多说，装好IDEA，一起来拆解快捷键吧！","categories":[{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/categories/编辑器/"},{"name":"个人感悟","slug":"编辑器/个人感悟","permalink":"https://blog.mariojd.cn/categories/编辑器/个人感悟/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://blog.mariojd.cn/tags/IDEA/"},{"name":"编辑器","slug":"编辑器","permalink":"https://blog.mariojd.cn/tags/编辑器/"},{"name":"Eclipse","slug":"Eclipse","permalink":"https://blog.mariojd.cn/tags/Eclipse/"},{"name":"个人感悟","slug":"个人感悟","permalink":"https://blog.mariojd.cn/tags/个人感悟/"}]},{"title":"Hexo整合GitHub Pages","slug":"Hexo整合GitHub Pages","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2018/02/08/Hexo整合GitHub Pages/","link":"","permalink":"https://blog.mariojd.cn/2018/02/08/Hexo整合GitHub Pages/","excerpt":"","text":"什么是hexo &emsp;&emsp;Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. &emsp;&emsp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 准备Node，Git环境 到Node官网下载安装包。Windows系统下的安装也很简单，下载最新版本的msi安装包，运行后一路点击Next就行，默认node会自动添加Path环境变量中，安装完后按Windows窗口键+R，cmd打开命令提示符界面，用node -v测试即可（PS：使用如下命令可更改为国内淘宝的NPM镜像源：npm install -g cnpm --registry=https://registry.npm.taobao.org， 这样以后就可以使用 cnpm 命令来安装第三方模块：cnpm install ） 安装Git，配置Git环境，具体操作过程这里就不在演示了，安装完了可以用命令git --version来测试 安装hexo cnpm install hexo -g，开始安装hexo hexo -v，用于检查hexo是否安装成功 创建空文件夹，在当前文件夹中输入hexo init进行初始化，最后输出的一句是：“Start blogging with Hexo！” cnpm install，安装相关依赖的组件 输入hexo g（等价于hexo generate），开始生成Hexo 输入hexo s（等价于hexo server），开启本地服务，默认为4000端口。端口占用的情况下，命令hexo server -p {port}可改变监听端口号 关联GitHub Page所在的仓库。在当前文件夹下，找到_config.yml文件，修改repository 新建文章，执行命令：hexo new post “my first blog”，可以在_posts文件夹下看到新创建的my first blog.md文件 安装扩展：cnpm install hexo-deployer-git --save 编辑好Markdown文章后，使用命令：hexo d -g，快速生成和部署远程仓库 部署成功后访问：https://{username}.github.io. 即可查看生成后的文章 关联域名 在source文件夹下新建名为CNAME的文件，输入域名，如：blog.mariojd.cn 使用命令hexo d -g部署到远程仓库 到域名提供商那里添加相应的域名解析 主机记录 记录类型 记录值 blog CNAME happyjared.github.io. 参考链接 Hexo官网Hexo文档Node官网Git官网","categories":[{"name":"开源项目","slug":"开源项目","permalink":"https://blog.mariojd.cn/categories/开源项目/"}],"tags":[{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://blog.mariojd.cn/tags/GitHub-Pages/"},{"name":"个人博客","slug":"个人博客","permalink":"https://blog.mariojd.cn/tags/个人博客/"},{"name":"开源项目","slug":"开源项目","permalink":"https://blog.mariojd.cn/tags/开源项目/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.mariojd.cn/tags/Hexo/"}]},{"title":"GitHub Pages介绍及搭建","slug":"GitHub Pages介绍及搭建","date":"un33fin33","updated":"un55fin55","comments":true,"path":"2018/02/07/GitHub Pages介绍及搭建/","link":"","permalink":"https://blog.mariojd.cn/2018/02/07/GitHub Pages介绍及搭建/","excerpt":"","text":"GitHub Page&emsp;&emsp;GitHub Page，一般多用于托管个人的静态网站，所以现在很多人也用来它来搭建私人博客，也算是省去了购买服务器、域名等等一系列复杂的操作。搭建博客网站有各种各样的方法，像懂php的可以用WordPress，懂Java的可以用Jpress等等。如果你想简单和简约，那么我强烈推荐你使用Github Page。在学习以下内容之前，请先准备好GitHub账号，如果没有请自行注册。 搭建流程 在GitHub中创建一个托管仓库，仓库的名字必须为：(or organization name).github.io。这里的username就是你的GitHub用户名，如果不知道，可以在GitHub中点击右上角的头像，在下拉里面有Signed in as XXX的信息，这就是你的账号名称。如果想修改你的账号名称，可以参考以下的步骤。 克隆当前仓库。 git clone 创建一个index.html到当前项目，可以尝试输入以下内容： &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;p&gt;I'm hosted with GitHub Pages.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 提交并推送到远程仓库。 git add index.html git commit -m “add index.html” 到此你就已经成功搭建完了GitHub Page。打开浏览器，并通过访问https://.github.io.来查看你的网站。 参考链接 GitHub PageGitHub HelpGitHub Pages Basics","categories":[{"name":"开源项目","slug":"开源项目","permalink":"https://blog.mariojd.cn/categories/开源项目/"}],"tags":[{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://blog.mariojd.cn/tags/GitHub-Pages/"},{"name":"个人博客","slug":"个人博客","permalink":"https://blog.mariojd.cn/tags/个人博客/"},{"name":"开源项目","slug":"开源项目","permalink":"https://blog.mariojd.cn/tags/开源项目/"}]},{"title":"Java类库：Lombok","slug":"Java类库：Lombok","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2017/10/22/Java类库：Lombok/","link":"","permalink":"https://blog.mariojd.cn/2017/10/22/Java类库：Lombok/","excerpt":"","text":"前言&emsp;&emsp;前阵子闲逛的时候，留意到了Lombok这个Java第三方库，后来亲自试用了一下，还真有一种相见恨晚的感觉，对于博主这样的懒人来说，这简直是太实用了。这不趁周末，赶紧把好东西写出来分享一下。 Lombok引述官网介绍： &emsp;&emsp;Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again. Early access to future java features such as val, and much more.&emsp;&emsp;Lombok是一个java库，它可以自动插入您的编辑器和构建工具，为您的java提供帮助。再也不要写其他的getter或equals方法了。尽早访问诸如val之类的未来java特性。 &emsp;&emsp;Tip：单人项目开发中使用极佳，或多人协作开发中强制要求使用相同环境。因为需要配置的原因，但目前编辑器和编译器还没有那么智能和友善o(╥﹏╥)o… 效果 未使用Lombok前的POJO大概是这样的（为了方便，下面把Entity、DTO、VO之类的都统称为POJO） public class User &#123; private Integer id; private String nickname; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getNickname() &#123; return nickname; &#125; public void setNickname(String nickname) &#123; this.nickname = nickname; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"nickname='\" + nickname + '\\'' + \", id=\" + id + '&#125;'; &#125;&#125; 使用了Lombok之后的POJO大概是这样的 @Datapublic class User &#123; private Integer id; private String nickname;&#125; 搭建 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 下载插件（IDEA） 配置支持 &emsp;&emsp;PS：IDEA中的Spring Initializr已集成Lombok，新建Spring Boot项目的时候勾选Lombok选择即可 说明图&emsp;&emsp;下面先来看下Lombok中几个主要常用注解介绍说明图： 具体说明 ```（常用）&amp;emsp;&amp;emsp;在类上使用此注解，相当于为当前类的非final字段添加了getter()、setter()、toString()、equals()以及hashCode()方法，同时这也是一个多功能组合注解，组合了下面的@ToString，@EqualsAndHashCode，@Getter，@Setter和@RequiredArgsConstructor这五个注解![@Data][7]* ``` @Builder ```（常用）&amp;emsp;&amp;emsp;此注解需用在类上。Lombok底层通过构造者模式来转换当前类，在项目实际使用的时候，我们可以以参数链的形式组装该对象，或者是以全参构造器的形式来new一个当前对象。当组合使用@Data注解的时候（一般来说是没必要的），Lombok也不会再为当前对象生成getter()、setter()方法。使用链式构造一个对象会显得更加优雅，所以这个注解也是非常实用的![@Builder][8]* ``` @Builder.Default ```（常用）&amp;emsp;&amp;emsp;此注解用在字段上。当前类使用了@Builder进行构造且某些字段含有默认值的情况下，需要为这些字段添加此注解，不加此注解默认值在构造的时候是不生效的，需要进行手动设值![@Builder.Default][9]* ``` @Slf4j ```（常用）``` java private final Logger logger = LoggerFactory.getLogger(getClass()); &emsp;&emsp;上面这段代码很熟悉吧。为当前类添加@Slf4j后，我们就可以舍弃这段代码了，是不是简洁多了 var ```（常用）&amp;emsp;&amp;emsp;val将局部变量申明为final类型，而var则用于修饰变量但不是final类型``` java val noLombok = new HashSet&lt;String&gt;(); var noLombok2=new ArrayList&lt;Integer&gt;(); ////=&gt; 以上这段代码相当于： final Set&lt;String&gt; useLombok = new HashSet&lt;&gt;(); List&lt;Integer&gt; useLombok2=new ArrayList&lt;&gt;(); ```（常用）&amp;emsp;&amp;emsp;该注解能够为方法，或构造函数的参数提供非空检查``` java public void notNull(@NonNull String arg) &#123; &#125; //=&gt; 以上这段代码相当于： public static void notNull(String arg) &#123; if (arg != null) &#123; &#125; else &#123; throw new NullPointerException(&quot;arg&quot;); &#125; &#125; ```（较常用）&amp;emsp;&amp;emsp;常用于资源释放``` java public void CleanUp() &#123; try &#123; @Cleanup Jedis jedis = redisService.getJedis(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //=&gt; 以上这段代码相当于： Jedis jedis = null; try &#123; jedis = redisService.getJedis(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (jedis != null) &#123; try &#123; jedis.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; ```（较常用）&amp;emsp;&amp;emsp;类似于 Synchronized 关键字，但是可以隐藏同步锁``` javapublic class SynchronizedExample &#123; private final Object readLock = new Object (); @Synchronized public static void test1() &#123; System.out.println(&quot;test1&quot;); &#125; @Synchronized(&quot;readLock&quot;) public void test2() &#123; System.out.println(&quot;test2&quot;); &#125;&#125; //=&gt; 以上这段代码相当于：public class SynchronizedExample &#123; private static final Object $LOCK = new Object[0]; private final Object readLock = new Object (); @Synchronized public static void test1() &#123; synchronized($LOCK) &#123; System.out.println(&quot;test1&quot;); &#125; &#125; @Synchronized(&quot;readLock&quot;) public void test2() &#123; synchronized(readLock) &#123; System.out.println(&quot;test2&quot;); &#125; &#125;&#125; @NoArgsConstructor, @RequiredArgsConstructor、@AllArgsConstructor （较常用） &emsp;&emsp;分别对应可生成无参构造器，指定参数的构造器和包含全部字段的构造器。第1个和第3个注解还是比较挺实用的，如果要生成部分参数的构造器，博主是比较建议手动生成，感觉注解还不太好用了。（注意：当类中有final字段没有被初始化时，编译器就会报错，此时可用@NoArgsConstructor(force = true)，然后就会为没有初始化的final字段设置默认值 0 / false / null。而对于具有约束的字段（如@NonNull字段），则不会生成检查或分配，因此要注意正确初始化final修饰的字段，否则这些约束都是无效的 @Getter、@Setter、@ToString、@EqualsAndHashCode （不常用） &emsp;&emsp;这几个注解都很好理解，见其名知其意，只是要注意注解的使用位置。对于@Getter和@Setter，默认生成的方法是public的，如果要修改方法的修饰符，可以设置AccessLevel的值，如：@Getter(access = AccessLevel.PROTECTED) @Value，@SneakyThrows ...（目测不常用） &emsp;&emsp;一些注解的具体用法还是参考Lombok官网吧 小结&emsp;&emsp;具体到实现原理方面，在下面的参考链接中也有相关的介绍，感兴趣的还请自行研究。结合最近的使用情况，觉得最舒服的就是临时加字段的情况下，也不需要我们再补上getter()、setter()和toString()。一般来说，我们只需要在POJO上用@Data 一个注解就基本满足了，还有@NoArgsConstructor，@AllArgsConstructor这两个注解有时候也经常用得上。 参考链接 lombok官网lombok - 简书lombok的使用和原理Java开发神器Lombok的使用与原理","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/categories/Java/"},{"name":"Lombok","slug":"Java/Lombok","permalink":"https://blog.mariojd.cn/categories/Java/Lombok/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.mariojd.cn/tags/Java/"},{"name":"Lombok","slug":"Lombok","permalink":"https://blog.mariojd.cn/tags/Lombok/"},{"name":"Java类库","slug":"Java类库","permalink":"https://blog.mariojd.cn/tags/Java类库/"}]}]}